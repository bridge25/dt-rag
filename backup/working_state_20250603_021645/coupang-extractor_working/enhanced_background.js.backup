/**
 * 쿠팡 상품 추출기 - 향상된 백그라운드 스크립트
 * 네이버 스마트스토어 템플릿을 위한 데이터 추출 및 변환 지원
 */

// 디버그 모드
const DEBUG = true;

// 모니터링 전역 상태 변수
let globalCrawlingState = {
  status: 'idle', // idle, running, paused, completed
  totalProgress: { current: 0, total: 0 },
  detailProgress: { current: 0, total: 0 },
  stats: { success: 0, error: 0, total: 0 },
  elapsedTime: 0,
  logs: [],
  maxLogs: 100
};

// 모니터링 페이지 목록 (연결된 모니터링 페이지들)
let monitorTabs = new Set();

// 실시간 업데이트 인터벌
let monitorUpdateInterval = null;

// 디버깅 로그 함수
function logDebug(message, type = 'info') {
  if (!DEBUG) return;
  
  const styles = {
    info: 'color: #0066cc;',
    success: 'color: #008000;',
    warning: 'color: #cc7700;',
    error: 'color: #cc0000;'
  };
  
  console.log(`%c[background] ${message}`, styles[type] || styles.info);
}

// 모니터링 상태 업데이트 함수
function updateCrawlingState(updates) {
  globalCrawlingState = { ...globalCrawlingState, ...updates };
  broadcastToMonitors('statusUpdate', globalCrawlingState);
}

// 모니터링 로그 추가 함수
function addMonitorLog(type, message) {
  const log = {
    timestamp: Date.now(),
    type: type, // 'info', 'success', 'warning', 'error'
    message: message
  };
  
  globalCrawlingState.logs.push(log);
  
  // 로그 개수 제한
  if (globalCrawlingState.logs.length > globalCrawlingState.maxLogs) {
    globalCrawlingState.logs.shift();
  }
  
  broadcastToMonitors('logUpdate', { log });
}

// 모니터링 페이지에 메시지 브로드캠스트
function broadcastToMonitors(type, data) {
  monitorTabs.forEach(tabId => {
    chrome.tabs.sendMessage(tabId, {
      action: 'monitorUpdate',
      type: type,
      data: data
    }).catch(error => {
      // 탭이 닫혔거나 없는 경우 목록에서 제거
      monitorTabs.delete(tabId);
    });
  });
}

// 실시간 업데이트 시작
function startMonitorUpdates() {
  if (monitorUpdateInterval) {
    clearInterval(monitorUpdateInterval);
  }
  
  monitorUpdateInterval = setInterval(() => {
    if (monitorTabs.size > 0) {
      broadcastToMonitors('statusUpdate', globalCrawlingState);
    }
  }, 1000); // 1초마다 업데이트
}

// 실시간 업데이트 중지
function stopMonitorUpdates() {
  if (monitorUpdateInterval) {
    clearInterval(monitorUpdateInterval);
    monitorUpdateInterval = null;
  }
}

// 키보드 단축키 명령 리스너
chrome.commands.onCommand.addListener((command) => {
  if (command === 'extract-products' || command === '_execute_action') {
    logDebug('확장 프로그램 활성화 단축키 감지', 'info');
    
    // 현재 활성 탭에서 상품 추출 실행
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]) {
        // 쿠팡 도메인 확인
        if (!tabs[0].url || !tabs[0].url.includes('coupang.com')) {
          logDebug('쿠팡 페이지가 아님', 'warning');
          chrome.notifications.create({
            type: 'basic',
            iconUrl: 'images/icon48.png',
            title: '쿠팡 상품 추출기',
            message: '쿠팡 웹사이트에서만 사용 가능합니다.'
          });
          return;
        }
        
        chrome.tabs.sendMessage(tabs[0].id, { action: 'extractProducts' }, (response) => {
          if (chrome.runtime.lastError) {
            logDebug('상품 추출 실패: ' + chrome.runtime.lastError.message, 'error');
            
            // 콘텐츠 스크립트 재주입
            chrome.scripting.executeScript({
              target: { tabId: tabs[0].id },
              files: ['enhanced_content.js']
            }, () => {
              setTimeout(() => {
                chrome.tabs.sendMessage(tabs[0].id, { action: 'extractProducts' }, (retryResponse) => {
                  if (!chrome.runtime.lastError && retryResponse) {
                    logDebug('재시도 상품 추출 성공', 'success');
                  }
                });
              }, 500);
            });
          } else {
            logDebug('상품 추출 응답: ' + JSON.stringify(response), 'success');
          }
        });
      }
    });
  }
});

// 확장 프로그램 아이콘 클릭 시 팝업 대신 직접 실행
chrome.action.onClicked.addListener((tab) => {
  logDebug('확장 프로그램 아이콘 클릭 감지', 'info');
  
  // 먼저 저장된 페이지 타입 확인
  chrome.storage.local.get([`tab_${tab.id}_pageType`], (result) => {
    const savedPageType = result[`tab_${tab.id}_pageType`];
    logDebug(`저장된 페이지 타입: ${savedPageType}`, 'info');
    
    // 쿠팡 도메인 확인
    if (!tab.url || !tab.url.includes('coupang.com')) {
      logDebug('쿠팡 페이지가 아님', 'warning');
      chrome.notifications.create({
        type: 'basic',
        iconUrl: 'images/icon48.png',
        title: '쿠팡 상품 추출기',
        message: '쿠팡 웹사이트에서만 사용 가능합니다.'
      });
      return;
    }
    
    // 상품 추출 명령 전송
    chrome.tabs.sendMessage(tab.id, { action: 'extractProducts' }, (response) => {
      if (chrome.runtime.lastError) {
        logDebug('상품 추출 실패: ' + chrome.runtime.lastError.message, 'error');
        
        // 콘텐츠 스크립트가 로드되지 않은 경우 재주입
        chrome.scripting.executeScript({
          target: { tabId: tab.id },
          files: ['enhanced_content.js']
        }, () => {
          // 재주입 후 다시 시도
          setTimeout(() => {
            chrome.tabs.sendMessage(tab.id, { action: 'extractProducts' }, (retryResponse) => {
              if (chrome.runtime.lastError) {
                chrome.notifications.create({
                  type: 'basic',
                  iconUrl: 'images/icon48.png',
                  title: '쿠팡 상품 추출기',
                  message: '페이지 새로고침 후 다시 시도해주세요.'
                });
              } else {
                logDebug('재시도 상품 추출 응답: ' + JSON.stringify(retryResponse), 'success');
              }
            });
          }, 500);
        });
      } else {
        logDebug('상품 추출 응답: ' + JSON.stringify(response), 'success');
        
        // 실패한 경우 상세 메시지 표시
        if (response && !response.success) {
          chrome.notifications.create({
            type: 'basic',
            iconUrl: 'images/icon48.png',
            title: '쿠팡 상품 추출기',
            message: response.error || '상품을 추출할 수 없습니다.'
          });
        }
      }
    });
  });
});

// 확장 프로그램 설치/업데이트 시
chrome.runtime.onInstalled.addListener(() => {
  logDebug('확장 프로그램 설치/업데이트 완료', 'success');
  
  // 컨텍스트 메뉴 생성
  chrome.contextMenus.create({
    id: 'extract-products',
    title: '쿠팡 상품 정보 추출',
    contexts: ['page']
  }, () => {
    if (chrome.runtime.lastError) {
      logDebug('컨텍스트 메뉴 생성 오류: ' + chrome.runtime.lastError.message, 'error');
    }
  });
});

// 컨텍스트 메뉴 클릭 핸들러
chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (info.menuItemId === 'extract-products') {
    chrome.tabs.sendMessage(tab.id, { action: 'extractProducts' });
  }
});

// 이벤트 위임을 통한 메시지 핸들러
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  logDebug(`메시지 수신: ${JSON.stringify(message)}`, 'info');
  
  // 모니터링 관련 메시지 처리
  if (message.action === 'registerMonitor') {
    // 모니터링 페이지 등록
    if (sender.tab && sender.tab.id) {
      monitorTabs.add(sender.tab.id);
      logDebug(`모니터링 페이지 등록: ${sender.tab.id}`, 'info');
      
      // 모니터링 업데이트 시작
      if (monitorTabs.size === 1) { // 첫 번째 모니터 등록 시
        startMonitorUpdates();
      }
      
      // 현재 상태 즉시 전송
      sendResponse({
        success: true,
        state: globalCrawlingState
      });
    }
    return true;
  }
  
  if (message.action === 'unregisterMonitor') {
    // 모니터링 페이지 해제
    if (sender.tab && sender.tab.id) {
      monitorTabs.delete(sender.tab.id);
      logDebug(`모니터링 페이지 해제: ${sender.tab.id}`, 'info');
      
      // 모니터링 페이지가 없으면 업데이트 중지
      if (monitorTabs.size === 0) {
        stopMonitorUpdates();
      }
    }
    sendResponse({ success: true });
    return true;
  }
  
  // pageDetected 메시지 처리 추가
  if (message.action === 'pageDetected') {
    logDebug(`페이지 감지: ${message.pageType} - ${message.url}`, 'info');
    // 페이지 타입 저장 (필요시 사용)
    if (sender.tab) {
      chrome.storage.local.set({
        [`tab_${sender.tab.id}_pageType`]: message.pageType,
        [`tab_${sender.tab.id}_url`]: message.url
      });
    }
    sendResponse({ success: true, pageType: message.pageType });
    return true;
  }
  
  // 기존 메시지 핸들링 (switch 대신 if-else)
  if (message.action === 'downloadProducts') {
    downloadExcel(message.products);
    sendResponse({ success: true });
  } else if (message.action === 'showNotification') {
    chrome.notifications.create({
      type: 'basic',
      iconUrl: 'images/icon48.png',
      title: message.title || '쿠팡 상품 추출기',
      message: message.message || '알림'
    });
    sendResponse({ success: true });
  } else if (message.action === 'logEvent') {
    console.log('[Event]', message.data);
    sendResponse({ success: true });
  }
  
  return true;
});

/**
 * Excel 파일 다운로드 함수
 */
function downloadExcel(products) {
  logDebug(`Excel 다운로드 시작: ${products.length}개 상품`, 'info');
  
  try {
    // 네이버 스마트스토어 템플릿 헤더
    const headers = [
      '상품명', '판매가', '재고수량', '상품주문번호', '카테고리ID',
      '상품상태', '상품 상세정보', '대표이미지URL', '추가이미지URL',
      '제조사', '브랜드', '제조일자', '유효일자', '부가세', '미성년자 구매',
      '구매평 노출여부', '원산지 코드', '수입사', '복수원산지 여부', '원산지 직접입력',
      '배송비 유형', '기본배송비', '배송방법', '배송비 결제방식', '조건부무료-상품판매가합계',
      '수량별부과-수량', '반품배송비', '교환배송비', '지역별 차등배송비 정보',
      '별도설치비', '판매자 특이사항', '즉시할인 값', '즉시할인 단위',
      '복수구매할인 조건 값', '복수구매할인 조건 단위', '복수구매할인 값', '복수구매할인 단위',
      '상품구매시 포인트 지급 값', '상품구매시 포인트 지급 단위', '텍스트리뷰 작성시 지급 포인트',
      '포토/동영상리뷰 작성시 지급 포인트', '한달사용텍스트리뷰 작성시 지급 포인트',
      '한달사용포토/동영상리뷰 작성시 지급 포인트', '톡톡친구/스토어찜고객리뷰 작성시 지급 포인트',
      '무이자 할부 개월', '사은품', '옵션형태', '옵션명', '옵션값', '옵션가',
      '옵션 재고수량', '추가상품명', '추가상품값', '추가상품가', '추가상품 재고수량',
      '상품정보제공고시 품명', '상품정보제공고시 모델명', '상품정보제공고시 인증허가사항',
      '상품정보제공고시 제조자', 'A/S 책임자와 전화번호', '상품정보제공고시 주문후 예상배송기간',
      '스토어찜회원 전용여부', '문화비소득공제', '입력형 옵션 타입', '입력형 옵션명',
      '최소구매수량', '상품 우선순위', '상품명(중국어)', '상품 상세정보(중국어)',
      '상품명(영어)', '상품 상세정보(영어)', '상품명(일본어)', '상품 상세정보(일본어)'
    ];
    
    // HTML 테이블 생성
    let html = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
<head>
<meta charset="UTF-8">
<style>
table { border-collapse: collapse; }
td, th { border: 1px solid #ddd; padding: 8px; }
th { background-color: #f2f2f2; font-weight: bold; }
</style>
<!--[if gte mso 9]><xml>
<x:ExcelWorkbook>
<x:ExcelWorksheets>
<x:ExcelWorksheet>
<x:Name>상품등록</x:Name>
<x:WorksheetOptions>
<x:DisplayGridlines/>
</x:WorksheetOptions>
</x:ExcelWorksheet>
</x:ExcelWorksheets>
</x:ExcelWorkbook>
</xml><![endif]-->
</head>
<body>
<table>`;
    
    // 헤더 행 추가
    html += '<tr>';
    headers.forEach(header => {
      html += `<th>${header}</th>`;
    });
    html += '</tr>';
    
    // 데이터 행 추가
    products.forEach(product => {
      html += '<tr>';
      
      // 상품명
      html += `<td>${product.title || ''}</td>`;
      
      // 판매가
      html += `<td>${product.price || ''}</td>`;
      
      // 재고수량 (기본값)
      html += '<td>100</td>';
      
      // 상품주문번호 (쿠팡 상품번호 사용)
      html += `<td>${product.productId || ''}</td>`;
      
      // 카테고리ID (기본값)
      html += '<td>50000000</td>';
      
      // 상품상태
      html += '<td>신상품</td>';
      
      // 상품 상세정보 (HTML 형태)
      let detailHtml = '';
      if (product.detailHtml) {
        detailHtml = product.detailHtml;
      } else if (product.imageUrls && product.imageUrls.length > 0) {
        // 이미지 URL들을 HTML img 태그로 변환
        product.imageUrls.forEach(url => {
          detailHtml += `<img src="${url}" style="max-width: 100%;"><br>`;
        });
      }
      html += `<td>${detailHtml}</td>`;
      
      // 대표이미지URL
      html += `<td>${product.imageUrl || ''}</td>`;
      
      // 추가이미지URL (|| 구분자로 연결)
      const additionalImages = product.imageUrls ? product.imageUrls.slice(1, 6).join('||') : '';
      html += `<td>${additionalImages}</td>`;
      
      // 제조사
      html += `<td>${product.manufacturer || ''}</td>`;
      
      // 브랜드
      html += `<td>${product.brand || ''}</td>`;
      
      // 나머지 필드들은 기본값 또는 빈값
      for (let i = 11; i < headers.length; i++) {
        html += '<td></td>';
      }
      
      html += '</tr>';
    });
    
    html += '</table></body></html>';
    
    // Blob 생성
    const blob = new Blob([html], { 
      type: 'application/vnd.ms-excel;charset=utf-8' 
    });
    
    // 파일명 생성
    const now = new Date();
    const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
    const filename = `coupang_to_naver_${timestamp}.xls`;
    
    // Service Worker에서는 URL.createObjectURL을 사용할 수 없으므로 data URL 사용
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    
    reader.onloadend = () => {
      const dataUrl = reader.result;
      
      // 다운로드
      chrome.downloads.download({
        url: dataUrl,
        filename: filename,
        saveAs: true
      });
      
      logDebug(`Excel 파일 다운로드 시작: ${filename}`, 'success');
    };
    
  } catch (error) {
    logDebug(`Excel 다운로드 실패: ${error.message}`, 'error');
    chrome.notifications.create({
      type: 'basic',
      iconUrl: 'images/icon48.png',
      title: '다운로드 실패',
      message: error.message
    });
  }
}

/**
 * 실제 탭을 사용한 상품 크롤링 함수
 */
async function crawlProductsWithRealTabs(products) {
  logDebug(`실제 탭을 사용한 ${products.length}개 상품 크롤링 시작`, 'info');
  console.log('[Background] crawlProductsWithRealTabs called with:', products);
  
  // 모니터링 상태 초기화
  updateCrawlingState({
    status: 'running',
    totalProgress: { current: 0, total: products.length },
    detailProgress: { current: 0, total: 0 },
    stats: { success: 0, error: 0, total: products.length },
    elapsedTime: 0
  });
  addMonitorLog('info', `크롤링 시작: 총 ${products.length}개 상품`);
  
  const startTime = Date.now();
  const BATCH_SIZE = 3; // 한 번에 처리할 상품 수를 3개로 제한
  const results = [];
  const crawlingStats = {
    total: products.length,
    completed: 0,
    failed: 0
  };
  
  // 성공률 모니터링 및 동적 속도 조절 시스템
  let delayMultiplier = 1; // 기본 속도 배수
  let sessionStats = { totalAttempts: 0, totalSuccesses: 0, totalFailures: 0 };
  
  // 이전 세션 통계 불러오기
  try {
    const storedStats = await chrome.storage.local.get(['crawlingSessionStats']);
    if (storedStats.crawlingSessionStats) {
      sessionStats = storedStats.crawlingSessionStats;
      logDebug(`세션 통계 불러오기: 성공 ${sessionStats.totalSuccesses}/${sessionStats.totalAttempts}`, 'info');
    }
  } catch (error) {
    logDebug('세션 통계 불러오기 실패: ' + error.message, 'warning');
  }
  
  // 현재 탭 ID 저장
  const [currentTab] = await chrome.tabs.query({ active: true, currentWindow: true });
  const originalTabId = currentTab.id;
  
  // 성공률 계산 및 속도 조절 함수
  const updateSuccessRate = async () => {
    const currentSuccessRate = sessionStats.totalAttempts > 0 
      ? (sessionStats.totalSuccesses / sessionStats.totalAttempts) * 100 
      : 0;
    const currentFailureRate = sessionStats.totalAttempts > 0
      ? (sessionStats.totalFailures / sessionStats.totalAttempts) * 100
      : 0;
    
    logDebug(`현재 성공률: ${currentSuccessRate.toFixed(1)}% (실패률: ${currentFailureRate.toFixed(1)}%)`, 'info');
    
    // 실패률 50% 초과 시 속도 조절
    if (currentFailureRate > 50 && sessionStats.totalAttempts >= 5) {
      const newMultiplier = Math.min(delayMultiplier * 2, 4); // 최대 4배까지
      if (newMultiplier > delayMultiplier) {
        delayMultiplier = newMultiplier;
        logDebug(`실패률 초과(${currentFailureRate.toFixed(1)}%) - 대기시간 ${delayMultiplier}배로 증가`, 'warning');
      }
    } else if (currentSuccessRate > 70 && sessionStats.totalAttempts >= 10) {
      // 성공률 70% 이상시 속도 복구
      const newMultiplier = Math.max(delayMultiplier * 0.8, 1); // 최소 1배
      if (newMultiplier < delayMultiplier) {
        delayMultiplier = newMultiplier;
        logDebug(`성공률 양호(${currentSuccessRate.toFixed(1)}%) - 대기시간 ${delayMultiplier.toFixed(1)}배로 감소`, 'success');
      }
    }
  };
  
  // 통계 저장 함수
  const saveSessionStats = async () => {
    try {
      await chrome.storage.local.set({ crawlingSessionStats: sessionStats });
    } catch (error) {
      logDebug('세션 통계 저장 실패: ' + error.message, 'error');
    }
  };
  // 로켓 상품 필터링 및 중복 제거
  const urlSet = new Set();
  const filteredProducts = [];
  let rocketCount = 0;
  let duplicateCount = 0;
  
  for (const product of products) {
    // 로켓 상품 필터링
    if (product.isRocket) {
      rocketCount++;
      logDebug(`로켓 상품 필터링: ${product.title || product.name}`, 'warning');
      continue;
    }
    
    // URL 중복 체크
    const productUrl = product.productUrl || product.url;
    if (urlSet.has(productUrl)) {
      duplicateCount++;
      logDebug(`중복 상품 필터링: ${product.title || product.name}`, 'warning');
      continue;
    }
    
    urlSet.add(productUrl);
    filteredProducts.push(product);
  }
  
  // 필터링 결과 로그
  logDebug(`필터링 결과: 전체 ${products.length}개 중 ${filteredProducts.length}개 크롤링 예정`, 'info');
  logDebug(`제외된 상품: 로켓 ${rocketCount}개, 중복 ${duplicateCount}개`, 'info');
  
  // 사용자에게 알림
  if (rocketCount > 0 || duplicateCount > 0) {
    chrome.notifications.create({
      type: 'basic',
      
      title: '상품 필터링 완료',
      message: `로켓 상품 ${rocketCount}개, 중복 상품 ${duplicateCount}개가 제외되었습니다.`
    });
  }
  
  // 크롤링 통계 업데이트
  crawlingStats.total = filteredProducts.length;
  
  // 크롤링 시작 알림
  chrome.notifications.create({
    type: 'basic',
    
    title: '크롤링 시작',
    message: `${filteredProducts.length}개 상품 크롤링을 시작합니다. 예상 소요 시간: ${Math.ceil(filteredProducts.length * 10 / 60)}분`
  });
  // 배치 단위로 처리
  for (let batchStart = 0; batchStart < filteredProducts.length; batchStart += BATCH_SIZE) {
    const batchEnd = Math.min(batchStart + BATCH_SIZE, filteredProducts.length);
    const batch = filteredProducts.slice(batchStart, batchEnd);
    
    logDebug(`배치 ${Math.floor(batchStart / BATCH_SIZE) + 1} 처리 시작 (${batch.length}개 상품)`, 'info');
    
    // 배치 내 각 상품 처리
    for (let j = 0; j < batch.length; j++) {
      const i = batchStart + j; // 전체 인덱스
      const product = batch[j];
      let tab; // 탭 변수를 try-catch 바깥에서 선언
    
    // 첫 번째 상품이 아닌 경우 요청 간격 추가 (쿠팡 봇 탐지 회피)
    // 첫 번째 상품이 아닌 경우 요청 간격 추가 (쿠팡 봇 탐지 회피)
    if (i > 0) {
      // 3-8초 사이의 랜덤 간격에 동적 속도 조절 적용 (최적화됨)
      const baseDelay = Math.random() * 5000 + 3000; // 3-8초로 단축
      const delay = baseDelay * delayMultiplier;
      logDebug(`다음 상품 크롤링까지 ${(delay/1000).toFixed(1)}초 대기 (속도조절: ${delayMultiplier.toFixed(1)}x)`, 'info');
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    try {
      // Frame Error 재시도 메커니즘 구현
      let retryCount = 0;
      const maxRetries = 3;
      let success = false;
      
      while (!success && retryCount < maxRetries) {
        try {
          if (retryCount > 0) {
            logDebug(`[${i + 1}/${filteredProducts.length}] 재시도 ${retryCount}/${maxRetries}: ${product.title}`, 'warning');
            // 재시도 전 대기 시간 (3초)
            await new Promise(resolve => setTimeout(resolve, 3000));
          }
          
          logDebug(`[${i + 1}/${filteredProducts.length}] 상품 크롤링: ${product.title}`, 'info');
          console.log(`[Background] Opening tab for product: ${product.title}, URL: ${product.productUrl}`);
      
      // 새 탭에서 상세페이지 열기
      tab = await chrome.tabs.create({
        url: product.productUrl, 
        active: false  // 백그라운드에서 열기
      });
      
      console.log(`[Background] Tab created with ID: ${tab.id}`);
      
      // 페이지가 완전히 로드될 때까지 대기
      await new Promise((resolve) => {
        const listener = (tabId, changeInfo) => {
          if (tabId === tab.id && changeInfo.status === 'complete') {
            chrome.tabs.onUpdated.removeListener(listener);
            console.log(`[Background] Tab ${tab.id} fully loaded`);
            resolve();
          }
        };
        chrome.tabs.onUpdated.addListener(listener);
        
                // 타임아웃 설정 (20초)
        setTimeout(() => {
          chrome.tabs.onUpdated.removeListener(listener);
                    logDebug(`Tab ${tab.id} load timeout - 정상 범위 내 동작으로 크롤링에 영향 없음`, 'debug');
          resolve();
                }, 20000);
      });
      
      console.log(`[Background] Executing extractDetailPageInfo on tab ${tab.id}`);
      
      // 상세 페이지 컨텐츠 로드 대기 (쿠팡은 동적으로 컨텐츠를 로드함) - 최적화
      await new Promise(resolve => setTimeout(resolve, 2000)); // 3초에서 2초로 단축
      
      // Frame Error 감지 및 상세 정보 추출
      const [detailResult] = await chrome.scripting.executeScript({
        target: { tabId: tab.id },
        func: function() {
          // extractDetailPageInfo 함수를 여기에 직접 정의
          console.log('[DetailExtract] Starting detail page extraction');
          console.log('[DetailExtract] Current URL:', window.location.href);
          
          const data = {
            galleryImages: [],
            detailImages: [],
            detailHtml: '',
            description: '',
            specifications: {},
            additionalInfo: {},
            error: null
          };
          
          try {
            // 1. 갤러리 이미지 추출 (상품 이미지)
            const gallerySelectors = [
              '.prod-image-list img',
              '.prod-thumb-list img',
              '.thumb-list img',
              '.prod-image__item img',
              'ul.subType-IMAGE img'
            ];
            
            for (const selector of gallerySelectors) {
              const images = document.querySelectorAll(selector);
              images.forEach(img => {
                const src = img.src || img.getAttribute('data-src');
                if (src && !src.includes('thumbnail') && !data.galleryImages.includes(src)) {
                  data.galleryImages.push(src);
                }
              });
            }
            
            // 2. 상세 설명 이미지 추출
            const detailSelectors = [
              '.prod-description img',
              '.product-detail img',
              '#productDetail img',
              '.detail-item img',
              '.subType-HTML img'
            ];
            
            for (const selector of detailSelectors) {
              const images = document.querySelectorAll(selector);
              images.forEach(img => {
                const src = img.src || img.getAttribute('data-src');
                if (src && !data.detailImages.includes(src)) {
                  data.detailImages.push(src);
                }
              });
            }
            
            // 3. 상세 HTML 추출
            const detailHtmlSelectors = [
              '.prod-description',
              '.product-detail',
              '#productDetail',
              '.detail-item'
            ];
            
            for (const selector of detailHtmlSelectors) {
              const element = document.querySelector(selector);
              if (element) {
                data.detailHtml = element.innerHTML;
                break;
              }
            }
            
          } catch (error) {
            console.error('상세 정보 추출 오류:', error);
            data.error = error.message;
          }
          
          console.log('[DetailExtract] Extraction completed, data:', data);
          return data;
        }
      });
      
      console.log(`[Background] Script execution result:`, detailResult);
      
      // Frame Error 감지 및 처리
      if (detailResult && detailResult.result && detailResult.result.error && 
          detailResult.result.error.includes('Frame with ID 0 is showing error page')) {
        throw new Error('Frame Error 발생 - 페이지 새로고침 필요');
      }
      
      if (detailResult && detailResult.result) {
        const detailData = detailResult.result;
        console.log(`[Background] Detail data extracted:`, detailData);
        console.log(`[Background] Number of detail images: ${detailData.detailImages ? detailData.detailImages.length : 0}`);
        
        // 디버그 정보 출력
        if (detailData.debug) {
          console.log(`[Background] Debug info:`, detailData.debug);
        }
        
        // 상품 정보와 상세 데이터 병합
        const mergedProduct = {
          ...product,
          ...detailData,
          status: 'completed'
        };
        
        results.push(mergedProduct);
        crawlingStats.completed++;
        
        // 세션 통계 업데이트 (성공)
        sessionStats.totalAttempts++;
        sessionStats.totalSuccesses++;
        await updateSuccessRate();
        await saveSessionStats();
        
        // 모니터링 상태 업데이트 (성공)
        const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        updateCrawlingState({
          totalProgress: { current: crawlingStats.completed + crawlingStats.failed, total: filteredProducts.length },
          stats: { success: crawlingStats.completed, error: crawlingStats.failed, total: filteredProducts.length },
          elapsedTime: elapsedTime
        });
        addMonitorLog('success', `상품 크롤링 성공: ${product.title}`);
        
        logDebug(`상품 크롤링 성공: ${product.title}`, 'success');
        console.log(`[Background] Product merged successfully:`, mergedProduct);
        
        // 성공 플래그 설정
        success = true;
      } else {
        console.error(`[Background] No detail result for tab ${tab.id}`);
        console.error(`[Background] detailResult:`, detailResult);
        throw new Error('상세 정보 추출 실패');
      }
      
        } catch (retryError) {
          retryCount++;
          console.error(`[Background] 재시도 ${retryCount} 실패 for ${product.title}:`, retryError);
          
          // Frame Error인 경우 페이지 새로고침
          if (retryError.message.includes('Frame Error 발생') && tab && tab.id) {
            try {
              console.log(`[Background] Frame Error 감지 - 페이지 새로고침 시도: ${tab.id}`);
              await chrome.tabs.reload(tab.id);
              // 새로고침 후 대기 시간 (3초)
              await new Promise(resolve => setTimeout(resolve, 3000));
            } catch (reloadError) {
              console.error(`[Background] 페이지 새로고침 실패:`, reloadError);
            }
          }
          
          // 최대 재시도 수에 도달한 경우 루프 종료
          if (retryCount >= maxRetries) {
            console.error(`[Background] 재시도 한계 초과: ${product.title}`);
            break;
          }
        }
      } // while 루프 종료
      
      // 성공하지 못한 경우 에러 처리
      if (!success) {
        throw new Error(`${maxRetries}번 재시도 후에도 실패`);
      }
      
      // 성공 시 탭 닫기
      if (tab && tab.id) {
        await chrome.tabs.remove(tab.id);
      }
    } catch (error) {
      console.error(`[Background] Crawling error for ${product.title}:`, error);
      console.error(`[Background] Error stack:`, error.stack);
      logDebug(`상품 크롤링 실패: ${product.title} - ${error.message}`, 'error');
      
      // 에러 발생 시에도 탭 닫기 시도
      if (tab && tab.id) {
        try {
          await chrome.tabs.remove(tab.id);
        } catch (removeError) {
          console.error(`[Background] Failed to close tab ${tab.id}:`, removeError);
        }
      }
      
      results.push({
        ...product,
        status: 'failed',
        error: error.message
      });
      crawlingStats.failed++;
      
      // 세션 통계 업데이트 (실패)
      sessionStats.totalAttempts++;
      sessionStats.totalFailures++;
      await updateSuccessRate();
      await saveSessionStats();
      
      // 모니터링 상태 업데이트 (실패)
      const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
      updateCrawlingState({
        totalProgress: { current: crawlingStats.completed + crawlingStats.failed, total: filteredProducts.length },
        stats: { success: crawlingStats.completed, error: crawlingStats.failed, total: filteredProducts.length },
        elapsedTime: elapsedTime
      });
      addMonitorLog('error', `상품 크롤링 실패: ${product.title} - ${error.message}`);
      
    }
    
    // 진행률 업데이트 (원래 탭으로 전송)
    chrome.tabs.sendMessage(originalTabId, {
      action: 'updateProgress',
      progress: {
        current: i + 1,
        total: filteredProducts.length,
        completed: crawlingStats.completed,
        failed: crawlingStats.failed
      }
    });
    
    // 25%, 50%, 75% 진행률에서 알림 표시
    const progressPercent = Math.floor(((i + 1) / filteredProducts.length) * 100);
    const milestones = [25, 50, 75];
    
    if (milestones.includes(progressPercent)) {
      const currentSuccessRate = crawlingStats.completed > 0 
        ? (crawlingStats.completed / (crawlingStats.completed + crawlingStats.failed)) * 100 
        : 0;
      
      chrome.notifications.create({
        type: 'basic',
        
        title: `크롤링 진행 ${progressPercent}%`,
        message: `${i + 1}/${filteredProducts.length} 상품 처리 완료. 성공률: ${currentSuccessRate.toFixed(1)}%`
      });
    }
    
    } // 배치 내 상품 처리 루프 종료
    
    // 다음 배치 처리 전 속도 조절이 적용된 대기 시간 (서버 부하 방지)
    if (batchEnd < filteredProducts.length) {
      const baseBatchDelay = 10000 + Math.random() * 5000; // 10-15초로 단축 (기존 20-30초)
      const batchDelay = baseBatchDelay * delayMultiplier;
      logDebug(`다음 배치 처리까지 ${(batchDelay/1000).toFixed(1)}초 대기 (속도조절: ${delayMultiplier.toFixed(1)}x)`, 'info');
      await new Promise(resolve => setTimeout(resolve, batchDelay));
    }
    } // 배치 처리 루프 종료
    
  // Excel 파일 생성
  try {
    const filename = await generateExcelFile(products, results);
    logDebug(`크롤링 및 Excel 파일 생성 완료: ${filename}`, 'success');
  } catch (error) {
    logDebug(`Excel 파일 생성 중 오류: ${error.message}`, 'error');
  }
  
  // 최종 성공률 리포트 및 통계 저장
  const finalSuccessRate = sessionStats.totalAttempts > 0 
    ? (sessionStats.totalSuccesses / sessionStats.totalAttempts) * 100 
    : 0;
  
  logDebug(`크롤링 완료 - 최종 성공률: ${finalSuccessRate.toFixed(1)}% (${sessionStats.totalSuccesses}/${sessionStats.totalAttempts})`, 'success');
  logDebug(`최종 속도 조절 배수: ${delayMultiplier.toFixed(1)}x`, 'info');
  
  // 최종 통계 저장
  await saveSessionStats();
  
  // 크롤링 완료 알림
  const completionMessage = crawlingStats.completed > 0 
    ? `성공: ${crawlingStats.completed}개, 실패: ${crawlingStats.failed}개 (${finalSuccessRate.toFixed(1)}% 성공률)`
    : `모든 상품 처리 실패 (총 ${crawlingStats.failed}개)`;
  
  chrome.notifications.create({
    type: 'basic',
    
    title: '크롤링 완료!',
    message: `총 ${filteredProducts.length}개 상품 처리 완료. ${completionMessage}`
  });
  
  // 모니터링 상태 업데이트 (완료)
  const totalElapsedTime = Math.floor((Date.now() - startTime) / 1000);
  updateCrawlingState({
    status: 'completed',
    totalProgress: { current: filteredProducts.length, total: filteredProducts.length },
    stats: { success: crawlingStats.completed, error: crawlingStats.failed, total: filteredProducts.length },
    elapsedTime: totalElapsedTime
  });
  addMonitorLog('info', `크롤링 완료: 총 소요시간 ${Math.floor(totalElapsedTime / 60)}분 ${totalElapsedTime % 60}초`);
  
  // 크롤링 결과 반환
  return {
    results: results,
    stats: crawlingStats
  };
}

  
  const data = {
    galleryImages: [],    // 상품 갤러리 이미지들 (추가이미지URL용)
    detailImages: [],     // 상세설명 섹션 이미지들 (상품 상세정보용)
    detailHtml: '',
    description: '',
    specifications: {},
    additionalInfo: {},
    debug: {
      imageSelectorsChecked: [],
      totalImagesFound: 0,
      htmlSelectorsChecked: [],
      htmlFound: false,
      galleryImagesFound: 0,
      detailImagesFound: 0,
      thumbnailsFiltered: 0
    }
  };
  
  try {
    // 1. 상세 HTML 컨텐츠 추출 (최우선)
    console.log('[DetailExtract] Looking for detail HTML content...');
    
    // 2025년 실제 쿠팡 DOM 구조에 맞춘 셀렉터들
    const detailHtmlSelectors = [
      // 2025년 실제 쿠팡 DOM 구조 (최우선 순위)
      '.prod-atf-main',  // Above the fold 메인 영역
      '.prod-btf-main',  // Below the fold 메인 영역 
      '.prod-description',  // 상품 설명 영역
      '.prod-buy-container',  // 구매 영역 컨테이너
      '.product-detail-content-inside',  // 상세 컨텐츠 내부
      '.prod-detail-info',  // 상세 정보
      '.detail-product-container',  // 상세 상품 컨테이너
      '.prod-description__detail',  // 상품 설명 상세
      '.product-item__detail',  // 상품 아이템 상세
      '.product-detail__content',  // 상품 상세 컨텐츠
      '.detail-content-wrapper',  // 상세 컨텐츠 래퍼
      
      // 기존 및 레거시 셀렉터들
      '#productDetail',
      '.product-detail',
      '.prod-detail-content',
      '.prod-description-content',
      '.detail-item',
      '.subType-IMAGE',
      '.subType-TEXT',
      '.subType-HTML',
      '#itemBrief',
      '.item-description',
      '.detail-section',
      '.product-detail-section',
      '.prod-detail-section',
      
      // 클래스 패턴 매칭
      '[class*="detail"][class*="content"]',
      '[class*="product"][class*="detail"]',
      '[id*="detail"]',
      '[class*="detail"]',
      '.detail-area',
      '.detail-info',
      '.detail-wrap'
    ];
    
    let detailHtmlContent = '';
    let foundValidContent = false;
    
    // 각 셀렉터로 상세 HTML 추출 시도
    for (const selector of detailHtmlSelectors) {
      try {
        const elements = document.querySelectorAll(selector);
        console.log(`[DetailExtract] Checking selector ${selector}: found ${elements.length} elements`);
        data.debug.htmlSelectorsChecked.push(`${selector}: ${elements.length}`);
        
        if (elements.length > 0) {
          // 각 요소 검사
          for (const element of elements) {
            // 요소의 클래스명과 ID 로깅
            console.log(`[DetailExtract] Element info - tagName: ${element.tagName}, class: "${element.className}", id: "${element.id}"`);
            
            // 이미지가 포함된 요소인지 확인
            const images = element.querySelectorAll('img');
            console.log(`[DetailExtract] Found ${images.length} images in this element`);
            
            // HTML 컨텐츠 미리보기
            const htmlPreview = element.innerHTML.substring(0, 200);
            console.log(`[DetailExtract] HTML preview: ${htmlPreview}...`);
            
            // 유효한 상세 컨텐츠인지 확인 (이미지가 3개 이상 있거나 충분한 텍스트가 있는 경우)
            if (images.length >= 3 || element.innerHTML.length > 500) {
              console.log(`[DetailExtract] Valid detail content found with selector: ${selector}`);
              
              // 이미지 URL만 추출하여 네이버 형식으로 변환
              const imageUrls = [];
              images.forEach(img => {
                let imgUrl = img.src || img.getAttribute('data-src') || img.getAttribute('data-lazy-src') || img.getAttribute('data-original');
                if (imgUrl && imgUrl.trim()) {
                  // 상대 경로를 절대 경로로 변환
                  if (imgUrl.startsWith('//')) {
                    imgUrl = 'https:' + imgUrl;
                  } else if (imgUrl.startsWith('/')) {
                    imgUrl = 'https://www.coupang.com' + imgUrl;
                  }
                  imageUrls.push(imgUrl);
                }
              });
              
              // 네이버 스마트스토어 형식으로 HTML 생성 (이미지만)
              if (imageUrls.length > 0) {
                detailHtmlContent = imageUrls.map(url => `<img src="${url}">`).join('');
                foundValidContent = true;
                data.debug.htmlFound = true;
                console.log(`[DetailExtract] Generated HTML with ${imageUrls.length} images`);
                break;
              }
            }
          }
          
          if (foundValidContent) break;
        }
      } catch (err) {
        console.error(`[DetailExtract] Error with selector ${selector}:`, err);
      }
    }
    
    // 상세 HTML을 찾지 못한 경우 대체 방법 시도
    if (!foundValidContent) {
      console.log('[DetailExtract] No valid detail HTML found, trying alternative methods...');
      
      // 방법 1: 모든 이미지 수집
      const allImagesInPage = document.querySelectorAll('img');
      const productImageUrls = [];
      
      allImagesInPage.forEach(img => {
        let imgUrl = img.src || img.getAttribute('data-src') || img.getAttribute('data-lazy-src');
        if (imgUrl && imgUrl.includes('coupangcdn.com') && !imgUrl.includes('thumbnail')) {
          // 상대 경로를 절대 경로로 변환
          if (imgUrl.startsWith('//')) {
            imgUrl = 'https:' + imgUrl;
          }
          productImageUrls.push(imgUrl);
        }
      });
      
      if (productImageUrls.length > 0) {
        detailHtmlContent = productImageUrls.map(url => `<img src="${url}">`).join('');
        console.log(`[DetailExtract] Alternative method: found ${productImageUrls.length} product images`);
      }
      
      // 방법 2: body 전체에서 상품 관련 영역 찾기
      if (!detailHtmlContent) {
        const bodyContent = document.body.innerHTML;
        const productAreaMatch = bodyContent.match(/<div[^>]*class="[^"]*prod[^"]*"[^>]*>[\s\S]*?<\/div>/gi);
        if (productAreaMatch) {
          console.log(`[DetailExtract] Found product area in body`);
          // 이미지 URL 추출
          const imgMatches = productAreaMatch[0].match(/<img[^>]+src=["']([^"']+)["'][^>]*>/gi);
          if (imgMatches) {
            const urls = imgMatches.map(match => {
              const urlMatch = match.match(/src=["']([^"']+)["']/);
              return urlMatch ? urlMatch[1] : null;
            }).filter(url => url && url.includes('coupangcdn.com'));
            
            if (urls.length > 0) {
              detailHtmlContent = urls.map(url => `<img src="${url}">`).join('');
              console.log(`[DetailExtract] Extracted ${urls.length} images from product area`);
            }
          }
        }
      }
    }
    
    // 최종 결과 저장 (상세 이미지만 사용)
    if (data.detailImages.length > 0) {
      data.detailHtml = data.detailImages.map(url => `<img src="${url}">`).join('');
    } else {
      data.detailHtml = detailHtmlContent || `<div>쿠팡상품번호: ${window.location.href.match(/products\/(\d+)/)?.[1] || 'unknown'}</div>`;
    }
    
    // detailHtml이 너무 짧은 경우 경고
    if (data.detailHtml.length < 100) {
      console.warn(`[DetailExtract] WARNING: DetailHtml too short (${data.detailHtml.length} chars), using fallback`);
      const productId = window.location.href.match(/products\/(\d+)/)?.[1] || 'unknown';
      data.detailHtml = `<div>쿠팡상품번호: ${productId}</div>`;
    }
    
    console.log(`[DetailExtract] Final detailHtml length: ${data.detailHtml.length}`);
    console.log(`[DetailExtract] DetailHtml preview: ${data.detailHtml.substring(0, 200)}...`);
    
    // 2. 갤러리 이미지 추출 (상품 상단 이미지들)
    console.log('[DetailExtract] Collecting gallery images...');
    const gallerySelectors = [
      '.prod-image__item img',
      '.prod-image__items img',
      '.prod-image-container img',
      '.product-image__item img',
      '.thumbnail-list img',
      '.prod-thumbnail img',
      '.prod-image-list img',
      '.product-image img'
    ];
    
    const galleryImageSet = new Set();
    
    // 썸네일 필터링 함수
    const isThumbnail = (url) => {
      if (!url) return true;
      const thumbnailPatterns = [
        /thumbnail/i,
        /thumb/i,
        /\bq\d{2}\b/,
        /230x230/,
        /120x120/,
        /292x292/,
        /48x48/
      ];
      return thumbnailPatterns.some(pattern => pattern.test(url));
    };
    
    gallerySelectors.forEach(selector => {
      const images = document.querySelectorAll(selector);
      if (images.length > 0) {
        console.log(`[DetailExtract] Found ${images.length} gallery images with selector: ${selector}`);
        data.debug.imageSelectorsChecked.push(`Gallery - ${selector}: ${images.length}`);
        
        images.forEach(img => {
          const urls = [
            img.src,
            img.getAttribute('data-src'),
            img.getAttribute('data-lazy-src'),
            img.getAttribute('data-original')
          ].filter(url => url && url.trim() && !isThumbnail(url));
          
          urls.forEach(url => {
            if (url.includes('coupangcdn.com')) {
              if (url.startsWith('//')) url = 'https:' + url;
              galleryImageSet.add(url);
              data.debug.galleryImagesFound++;
            }
          });
        });
      }
    });
    
    // 3. 상세 이미지 추출 (상세설명 섹션)
    console.log('[DetailExtract] Collecting detail images...');
    const detailSelectors = [
      '.prod-detail-content img',
      '.prod-detail img',
      '.detail-item img',
      '.subType-IMAGE img',
      '#productDetail img',
      '.detail-product-container img',
      '.product-detail-content img',
      '.prod-description-attribute img',
      '.vendor-item img'
    ];
    
    const detailImageSet = new Set();
    
    detailSelectors.forEach(selector => {
      const images = document.querySelectorAll(selector);
      if (images.length > 0) {
        console.log(`[DetailExtract] Found ${images.length} detail images with selector: ${selector}`);
        data.debug.imageSelectorsChecked.push(`Detail - ${selector}: ${images.length}`);
        
        images.forEach(img => {
          const urls = [
            img.src,
            img.getAttribute('data-src'),
            img.getAttribute('data-lazy-src'),
            img.getAttribute('data-original')
          ].filter(url => url && url.trim() && !isThumbnail(url));
          
          urls.forEach(url => {
            if (url.includes('coupangcdn.com')) {
              if (url.startsWith('//')) url = 'https:' + url;
              detailImageSet.add(url);
              data.debug.detailImagesFound++;
            }
          });
        });
      }
    });
    
    data.galleryImages = Array.from(galleryImageSet);
    data.detailImages = Array.from(detailImageSet);
    
    console.log(`[DetailExtract] Extraction results:`);
    console.log(`  - Gallery images: ${data.galleryImages.length}`);
    console.log(`  - Detail images: ${data.detailImages.length}`);
    console.log(`  - Total unique images: ${data.galleryImages.length + data.detailImages.length}`);
    
    // 3. 상품 설명 추출
    const descElement = document.querySelector('.prod-description, .product-description');
    if (descElement) {
      data.description = descElement.textContent.trim();
    }
    
    // 4. 상품 사양 추출
    const specElements = document.querySelectorAll('.prod-spec li, .spec-list li');
    specElements.forEach(spec => {
      const key = spec.querySelector('.spec-name, .title');
      const value = spec.querySelector('.spec-value, .value');
      if (key && value) {
        data.specifications[key.textContent.trim()] = value.textContent.trim();
      }
    });
    
    // 5. 추가 정보
    const priceElement = document.querySelector('.total-price strong, .prod-price .total-price');
    if (priceElement) {
      data.additionalInfo.finalPrice = priceElement.textContent.trim();
    }
    
    const deliveryElement = document.querySelector('.prod-shipping-fee-message, .delivery-fee');
    if (deliveryElement) {
      data.additionalInfo.deliveryInfo = deliveryElement.textContent.trim();
    }
    
  } catch (error) {
    console.error('상세 정보 추출 오류:', error);
    data.error = error.message;
  }
  
  console.log('[DetailExtract] Extraction completed, data:', data);

// 안전한 응답 전송 헬퍼 함수
function safeSendResponse(sendResponse, data) {
  try {
    // 채널 유효성 검사
    if (chrome.runtime.lastError) {
      logDebug(`메시지 채널 오류: ${chrome.runtime.lastError.message}`, 'debug');
      return false;
    }
    
    // 응답 전송 시도
    sendResponse(data);
    return true;
  } catch (error) {
    logDebug(`응답 전송 실패 (정상 범위 내): ${error.message}`, 'debug');
    return false;
  }
}

// 새로운 메시지 핸들러 추가
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log('[Background] Message received:', message);
  if (message.action === 'startRealDetailCrawling') {
    console.log('[Background] startRealDetailCrawling handler triggered');
    crawlProductsWithRealTabs(message.products)
      .then(result => {
        console.log('[Background] Crawling completed successfully:', result);
                safeSendResponse(sendResponse, { success: true, ...result });
      })
      .catch(error => {
        console.error('[Background] Crawling failed:', error);
                safeSendResponse(sendResponse, { success: false, error: error.message });
      });
    return true; // 비동기 응답
  }
});

/**
 * Excel 파일 생성 및 다운로드 함수
 */
async function generateExcelFile(products, crawlResults) {
  logDebug('Excel 파일 생성 시작', 'info');
  
  try {
    // 네이버 스마트스토어 템플릿 헤더
    const headers = [
      '상품명', '판매가', '재고수량', '상품주문번호', '카테고리ID',
      '상품상태', '상품 상세정보', '대표이미지URL', '추가이미지URL',
      '제조사', '브랜드', '제조일자', '유효일자', '부가세', '미성년자 구매',
      '구매평 노출여부', '원산지 코드', '수입사', '복수원산지 여부', '원산지 직접입력',
      '배송비 유형', '기본배송비', '배송방법', '배송비 결제방식', '조건부무료-상품판매가합계',
      '수량별부과-수량', '반품배송비', '교환배송비', '지역별 차등배송비 정보',
      '별도설치비', '판매자 특이사항', '즉시할인 값', '즉시할인 단위',
      '복수구매할인 조건 값', '복수구매할인 조건 단위', '복수구매할인 값', '복수구매할인 단위',
      '상품구매시 포인트 지급 값', '상품구매시 포인트 지급 단위', '텍스트리뷰 작성시 지급 포인트',
      '포토/동영상리뷰 작성시 지급 포인트', '한달사용텍스트리뷰 작성시 지급 포인트',
      '한달사용포토/동영상리뷰 작성시 지급 포인트', '톡톡친구/스토어찜고객리뷰 작성시 지급 포인트',
      '무이자 할부 개월', '사은품', '옵션형태', '옵션명', '옵션값', '옵션가',
      '옵션 재고수량', '추가상품명', '추가상품값', '추가상품가', '추가상품 재고수량',
      '상품정보제공고시 품명', '상품정보제공고시 모델명', '상품정보제공고시 인증허가사항',
      '상품정보제공고시 제조자', 'A/S 책임자와 전화번호', '상품정보제공고시 주문후 예상배송기간',
      '스토어찜회원 전용여부', '문화비소득공제', '입력형 옵션 타입', '입력형 옵션명',
      '최소구매수량', '상품 우선순위', '상품명(중국어)', '상품 상세정보(중국어)',
      '상품명(영어)', '상품 상세정보(영어)', '상품명(일본어)', '상품 상세정보(일본어)'
    ];
    
    // HTML 테이블 생성
    let html = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
<head>
<meta charset="UTF-8">
<style>
table { border-collapse: collapse; }
td, th { border: 1px solid #ddd; padding: 8px; }
th { background-color: #f2f2f2; font-weight: bold; }
</style>
<!--[if gte mso 9]><xml>
<x:ExcelWorkbook>
<x:ExcelWorksheets>
<x:ExcelWorksheet>
<x:Name>상품등록</x:Name>
<x:WorksheetOptions>
<x:DisplayGridlines/>
</x:WorksheetOptions>
</x:ExcelWorksheet>
</x:ExcelWorksheets>
</x:ExcelWorkbook>
</xml><![endif]-->
</head>
<body>
<table>`;
    
    // 헤더 행 추가
    html += '<tr>';
    headers.forEach(header => {
      html += `<th>${header}</th>`;
    });
    html += '</tr>';
    
    // 데이터 행 추가
    for (let i = 0; i < products.length; i++) {
      const product = products[i];
      console.log(`[generateExcelFile] Processing product ${i}: ${product.title}, URL: ${product.productUrl}`);
      const crawlResult = crawlResults.find(r => r.url === product.productUrl || r.productUrl === product.productUrl);
      console.log(`[generateExcelFile] Crawl result found:`, crawlResult ? 'Yes' : 'No');
      
      // detailHtml 확인 및 로깅
      let detailHtml = '';
      if (crawlResult) {
        if (crawlResult.detailHtml) {
          detailHtml = crawlResult.detailHtml;
          console.log(`[generateExcelFile] Using crawlResult.detailHtml, length: ${detailHtml.length}`);
        } else if (crawlResult.data && crawlResult.data.detailHtml) {
          detailHtml = crawlResult.data.detailHtml;
          console.log(`[generateExcelFile] Using crawlResult.data.detailHtml, length: ${detailHtml.length}`);
        } else {
          console.log(`[generateExcelFile] No detailHtml found in crawlResult`);
        }
      }
      
      html += '<tr>';
      
      // 상품명
      html += `<td>${product.title || ''}</td>`;
      
      // 판매가
      html += `<td>${product.price ? product.price.replace(/[^0-9]/g, '') : ''}</td>`;
      
      // 재고수량 (기본값)
      html += '<td>100</td>';
      
      // 상품주문번호 (쿠팡 상품번호 사용)
      const productIdMatch = product.productUrl ? product.productUrl.match(/products\/(\d+)/) : null;
      html += `<td>${productIdMatch ? productIdMatch[1] : ''}</td>`;
      
      // 카테고리ID (기본값)
      html += '<td>50000000</td>';
      
      // 상품상태
      html += '<td>신상품</td>';
      
      // 상품 상세정보 - 개선된 처리
      let finalDetailHtml = '';
      
      // 1. crawlResult에서 detailHtml 확인
      if (detailHtml && detailHtml.length > 50) {
        // HTML 엔티티 인코딩 (Excel에서 HTML 태그를 표시하기 위함)
        finalDetailHtml = detailHtml
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
        console.log(`[generateExcelFile] Product ${i}: Using extracted detailHtml`);
      } 
      // 2. 백업: 상세 이미지들로 HTML 생성
      else if (crawlResult && crawlResult.data && crawlResult.data.detailImages && crawlResult.data.detailImages.length > 0) {
        finalDetailHtml = crawlResult.data.detailImages
          .map(imgUrl => `&lt;img src="${imgUrl}" style="max-width: 100%;"&gt;&lt;br&gt;`)
          .join('');
        console.log(`[generateExcelFile] Product ${i}: Generated HTML from ${crawlResult.data.detailImages.length} detail images`);
      }
      else if (crawlResult && crawlResult.detailImages && crawlResult.detailImages.length > 0) {
        finalDetailHtml = crawlResult.detailImages
          .map(imgUrl => `&lt;img src="${imgUrl}" style="max-width: 100%;"&gt;&lt;br&gt;`)
          .join('');
        console.log(`[generateExcelFile] Product ${i}: Generated HTML from ${crawlResult.detailImages.length} detail images (direct)`);
      }
      // 3. 최종 폴백: 기본 상품 정보
      else {
        finalDetailHtml = `&lt;div&gt;쿠팡상품번호: ${productIdMatch ? productIdMatch[1] : 'unknown'}&lt;/div&gt;`;
        console.log(`[generateExcelFile] Product ${i}: Using fallback product ID`);
      }
      
      html += `<td>${finalDetailHtml}</td>`;
      
      // 대표이미지URL
      html += `<td>${product.imageUrl || ''}</td>`;
      
      // 추가이미지URL (갤러리 이미지 사용, 개수 제한 없음)
      let additionalImages = '';
      
      // galleryImages 찾기
      if (crawlResult && crawlResult.data && crawlResult.data.galleryImages) {
        additionalImages = crawlResult.data.galleryImages.join('||');
        console.log(`[generateExcelFile] Found ${crawlResult.data.galleryImages.length} gallery images`);
      } else if (crawlResult && crawlResult.galleryImages) {
        additionalImages = crawlResult.galleryImages.join('||');
        console.log(`[generateExcelFile] Found ${crawlResult.galleryImages.length} gallery images (direct)`);
      } else {
        // 폴백: detailImages 사용
        if (crawlResult && crawlResult.data && crawlResult.data.detailImages) {
          additionalImages = crawlResult.data.detailImages.slice(0, 5).join('||');
          console.log(`[generateExcelFile] Fallback: using detailImages`);
        } else if (crawlResult && crawlResult.detailImages) {
          additionalImages = crawlResult.detailImages.slice(0, 5).join('||');
        }
      }
      html += `<td>${additionalImages}</td>`;
      
      // 나머지 필드들 (기본값)
      // 제조사부터 원산지 코드까지 11개 필드
      html += '<td></td>'.repeat(10); // 제조사 ~ 부가세, 미성년자 구매, 구매평 노출여부
      html += '<td>0200037</td>'; // 원산지 코드
      html += '<td></td>'.repeat(3); // 수입사, 복수원산지 여부, 원산지 직접입력
      
      // 배송 정보
      html += '<td>무료</td>'; // 배송비 유형
      html += '<td>0</td>'; // 기본배송비
      html += '<td>택배</td>'; // 배송방법
      html += '<td>무료</td>'; // 배송비 결제방식
      
      // 나머지 모든 필드 기본값
      html += '<td></td>'.repeat(headers.length - 24);
      
      html += '</tr>';
    }
    
    html += '</table></body></html>';
    
    // Blob 생성
    const blob = new Blob([html], { 
      type: 'application/vnd.ms-excel;charset=utf-8' 
    });
    
    // 파일명 생성
    const now = new Date();
    const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
    const filename = `coupang_to_naver_${timestamp}.xls`;
    
    // Service Worker에서는 URL.createObjectURL을 사용할 수 없으므로 data URL 사용
    const reader = new FileReader();
    reader.readAsDataURL(blob);
    
    reader.onloadend = async () => {
      const dataUrl = reader.result;
      
      // 다운로드
      await chrome.downloads.download({
        url: dataUrl,
        filename: filename,
        saveAs: false
      });
      
      logDebug(`Excel 파일 생성 완료: ${filename}`, 'success');
    };
    
    return filename;
  } catch (error) {
    logDebug(`Excel 파일 생성 실패: ${error.message}`, 'error');
    throw error;
  }
}