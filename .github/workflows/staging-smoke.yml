name: staging-smoke

on:
  workflow_dispatch:
    inputs:
      api_base:
        description: 'Staging API Base URL'
        required: false
        default: 'http://localhost:8000'
        type: string
      test_timeout:
        description: 'Test timeout in seconds'
        required: false
        default: '300'
        type: string
  push:
    paths:
      - "scripts/smoke.sh"
      - "docs/bridge/**"
      - "docs/seeds/minimal/**"
      - ".github/workflows/staging-smoke.yml"
    branches:
      - main
      - "dt-rag/**"
      - "feature/**"
  pull_request:
    paths:
      - "scripts/smoke.sh"
      - "docs/bridge/**"
      - "docs/seeds/minimal/**"
      - ".github/workflows/staging-smoke.yml"
  schedule:
    - cron: "*/30 * * * *"   # Every 30 minutes for continuous monitoring

env:
  STAGING_API_BASE: ${{ vars.STAGING_API_BASE || inputs.api_base || 'http://localhost:8000' }}
  API_KEY: ${{ secrets.STAGING_API_KEY }}
  DATABASE_URL: postgresql://postgres:testpassword@localhost:5432/dt_rag_test
  OPENAI_API_KEY: dummy-key-for-testing

jobs:
  smoke-test:
    runs-on: ubuntu-latest
    timeout-minutes: ${{ fromJSON(inputs.test_timeout || '5') }}

    services:
      postgres:
        image: ankane/pgvector
        env:
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: dt_rag_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
          
      - name: Validate environment
        run: |
          echo "üîç Validating environment variables..."
          echo "STAGING_API_BASE: ${STAGING_API_BASE}"
          echo "API_KEY: ${API_KEY:0:8}..." # Show only first 8 chars for security
          
          if [[ -z "${API_KEY}" ]]; then
            echo "‚ùå ERROR: STAGING_API_KEY secret not configured"
            echo "Please configure repository secret: STAGING_API_KEY"
            exit 1
          fi
          
          if [[ -z "${STAGING_API_BASE}" ]]; then
            echo "‚ùå ERROR: STAGING_API_BASE not configured"
            echo "Please configure repository variable: STAGING_API_BASE"
            exit 1
          fi
          
      - name: Check script permissions
        run: |
          ls -la scripts/smoke.sh
          chmod +x scripts/smoke.sh

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Start API server
        run: |
          echo "üöÄ Starting RAG API server..."
          cd apps/api

          # Install Python dependencies with optimizations
          pip install --upgrade pip
          pip install wheel

          # Install only essential dependencies for smoke tests
          pip install fastapi uvicorn pydantic python-multipart
          pip install sqlalchemy asyncpg alembic
          pip install httpx numpy scikit-learn
          pip install pgvector

          # Skip heavy ML dependencies that aren't needed for basic API tests
          # pip install -r requirements.txt

          # Start API server in background
          echo "üì° Starting server on port 8000..."
          python main.py &
          API_PID=$!
          echo "API_PID=$API_PID" >> $GITHUB_ENV

          # Wait for server to start
          echo "‚è≥ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -s http://localhost:8000/healthz > /dev/null 2>&1; then
              echo "‚úÖ API server is ready!"
              break
            fi
            echo "‚è≥ Attempt $i/30: Server not ready yet, waiting..."
            sleep 2
          done

          # Final check
          if ! curl -s http://localhost:8000/healthz > /dev/null 2>&1; then
            echo "‚ùå API server failed to start properly"
            exit 1
          fi

      - name: Run smoke tests
        id: smoke_test
        run: |
          echo "üöÄ Starting Bridge Pack smoke tests..."
          echo "üìç Target: ${STAGING_API_BASE}"
          
          # Run the smoke test script
          ./scripts/smoke.sh
          
          # Capture exit code
          exit_code=$?
          
          if [ $exit_code -eq 0 ]; then
            echo "smoke_status=success" >> $GITHUB_OUTPUT
            echo "üéâ All smoke tests passed!"
          else
            echo "smoke_status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Smoke tests failed with exit code: $exit_code"
            exit $exit_code
          fi

      - name: Stop API server
        if: always()
        run: |
          echo "üõë Stopping API server..."
          if [ ! -z "$API_PID" ]; then
            kill $API_PID || true
            echo "‚úÖ API server stopped (PID: $API_PID)"
          else
            echo "‚ö†Ô∏è No API server PID found, attempting to kill by port..."
            pkill -f "python main.py" || true
          fi

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-results-${{ github.run_number }}
          path: |
            scripts/smoke.sh
            docs/bridge/ACCESS_CARD.md
            docs/seeds/minimal/EXPECTED.md
          retention-days: 30
          
      - name: Comment on PR (if applicable)
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const smokeStatus = '${{ steps.smoke_test.outputs.smoke_status }}';
            const apiBase = '${{ env.STAGING_API_BASE }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';
            
            const status = smokeStatus === 'success' ? '‚úÖ PASSED' : '‚ùå FAILED';
            const emoji = smokeStatus === 'success' ? 'üéâ' : 'üí•';
            
            const comment = `## ${emoji} Bridge Pack Smoke Test Results
            
            **Status**: ${status}
            **API Base**: ${apiBase}
            **Run Details**: [View full results](${runUrl})
            
            ### Test Coverage
            - ‚úÖ Health Check (\`GET /healthz\`)
            - ‚úÖ Taxonomy Tree (\`GET /taxonomy/1.8.1/tree\`)  
            - ‚úÖ Document Classify (\`POST /classify\`)
            - ‚úÖ Document Search (\`POST /search\`)
            
            ${smokeStatus === 'success' 
              ? 'üöÄ **B-team can integrate with confidence!** All endpoints are responding correctly.' 
              : 'üîß **Action Required**: Please check the failing endpoints before integration.'}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  validate-access-card:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Validate ACCESS_CARD.md
        run: |
          echo "üîç Validating ACCESS_CARD.md..."
          
          if [[ ! -f "docs/bridge/ACCESS_CARD.md" ]]; then
            echo "‚ùå ACCESS_CARD.md not found"
            exit 1
          fi
          
          # Check for required sections
          required_sections=(
            "BASE URL"
            "SPEC"
            "Health"
            "Auth"
            "How to set env"
          )
          
          for section in "${required_sections[@]}"; do
            if ! grep -q "$section" docs/bridge/ACCESS_CARD.md; then
              echo "‚ùå Missing section: $section"
              exit 1
            fi
          done
          
          echo "‚úÖ ACCESS_CARD.md validation passed"
          
      - name: Validate seed files
        run: |
          echo "üîç Validating seed files..."
          
          seed_files=(
            "docs/seeds/minimal/sample.md"
            "docs/seeds/minimal/sample.html"
            "docs/seeds/minimal/EXPECTED.md"
          )
          
          for file in "${seed_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Seed file not found: $file"
              exit 1
            fi
          done
          
          echo "‚úÖ Seed files validation passed"

  security-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Check for secrets in files
        run: |
          echo "üîí Checking for accidentally committed secrets..."
          
          # Check for common secret patterns
          secret_patterns=(
            "api_key.*=.*[a-zA-Z0-9]{20,}"
            "password.*=.*[a-zA-Z0-9]{8,}"
            "token.*=.*[a-zA-Z0-9]{16,}"
            "secret.*=.*[a-zA-Z0-9]{16,}"
          )
          
          for pattern in "${secret_patterns[@]}"; do
            if grep -r -i -E "$pattern" docs/ scripts/ --include="*.md" --include="*.sh"; then
              echo "‚ùå Potential secret found matching pattern: $pattern"
              echo "Please remove secrets from committed files"
              exit 1
            fi
          done
          
          echo "‚úÖ No secrets found in committed files"

  notify-failure:
    runs-on: ubuntu-latest
    needs: [smoke-test, validate-access-card, security-check]
    if: failure() && github.event_name == 'schedule'
    steps:
      - name: Notify Slack on scheduled failure
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "üö® Staging Smoke Test Failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*üö® Staging Smoke Test Failed*\n\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Run:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>\n\n*Environment:* ${{ env.STAGING_API_BASE }}\n*Time:* ${{ github.event.head_commit.timestamp }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "‚ö†Ô∏è *Action Required*: Check staging environment health and API availability."
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create GitHub Issue on repeated failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = 'üö® Staging Smoke Test Repeated Failure';
            const body = `
            ## Staging Smoke Test Failure Alert
            
            **Environment**: ${process.env.STAGING_API_BASE}
            **Failed Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            **Time**: ${{ github.event.head_commit.timestamp }}
            
            ## Possible Causes
            - [ ] Staging environment is down
            - [ ] API key expired or invalid
            - [ ] Network connectivity issues
            - [ ] Service deployment failure
            
            ## Action Items
            - [ ] Check staging environment health
            - [ ] Verify API key validity
            - [ ] Review recent deployments
            - [ ] Update status page if needed
            
            **Auto-generated by staging-smoke workflow**
            `;
            
            // Check if similar issue exists
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'staging,smoke-test,automated'
            });
            
            const existingIssue = issues.data.find(issue => 
              issue.title.includes('Staging Smoke Test') && 
              issue.title.includes('Failure')
            );
            
            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['staging', 'smoke-test', 'automated', 'bug']
              });
            }