"""
Vulnerability Scanner for DT-RAG v1.8.1
Comprehensive security vulnerability assessment and code analysis
OWASP Top 10 compliant with automated remediation suggestions
"""

import ast
import re
import hashlib
import subprocess
import asyncio
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path
import uuid
import bandit
from bandit.core import manager
import safety
import semgrep
import requests

logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    """OWASP Top 10 vulnerability types"""
    # A01:2021 – Broken Access Control
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    INSECURE_DIRECT_OBJECT_REFERENCE = "insecure_direct_object_reference"
    MISSING_AUTHORIZATION = "missing_authorization"

    # A02:2021 – Cryptographic Failures
    WEAK_ENCRYPTION = "weak_encryption"
    HARDCODED_SECRETS = "hardcoded_secrets"
    INSECURE_RANDOM = "insecure_random"
    WEAK_HASHING = "weak_hashing"

    # A03:2021 – Injection
    SQL_INJECTION = "sql_injection"
    NOSQL_INJECTION = "nosql_injection"
    COMMAND_INJECTION = "command_injection"
    LDAP_INJECTION = "ldap_injection"
    XSS_STORED = "xss_stored"
    XSS_REFLECTED = "xss_reflected"

    # A04:2021 – Insecure Design
    INSECURE_DESIGN = "insecure_design"
    MISSING_RATE_LIMITING = "missing_rate_limiting"
    INSUFFICIENT_LOGGING = "insufficient_logging"

    # A05:2021 – Security Misconfiguration
    DEFAULT_CREDENTIALS = "default_credentials"
    UNNECESSARY_FEATURES = "unnecessary_features"
    OUTDATED_COMPONENTS = "outdated_components"
    IMPROPER_ERROR_HANDLING = "improper_error_handling"

    # A06:2021 – Vulnerable and Outdated Components
    KNOWN_VULNERABILITIES = "known_vulnerabilities"
    DEPENDENCY_CONFUSION = "dependency_confusion"
    SUPPLY_CHAIN_ATTACK = "supply_chain_attack"

    # A07:2021 – Identification and Authentication Failures
    WEAK_PASSWORDS = "weak_passwords"
    SESSION_FIXATION = "session_fixation"
    INSECURE_SESSION_MANAGEMENT = "insecure_session_management"
    CREDENTIAL_STUFFING = "credential_stuffing"

    # A08:2021 – Software and Data Integrity Failures
    UNSIGNED_UPDATES = "unsigned_updates"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    CI_CD_COMPROMISE = "ci_cd_compromise"

    # A09:2021 – Security Logging and Monitoring Failures
    INSUFFICIENT_MONITORING = "insufficient_monitoring"
    MISSING_AUDIT_LOGS = "missing_audit_logs"
    LOG_INJECTION = "log_injection"

    # A10:2021 – Server-Side Request Forgery
    SSRF = "ssrf"
    URL_REDIRECT = "url_redirect"

class SeverityLevel(Enum):
    """Vulnerability severity levels"""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class ScanType(Enum):
    """Types of security scans"""
    STATIC_CODE_ANALYSIS = "static_code_analysis"
    DEPENDENCY_SCAN = "dependency_scan"
    CONFIGURATION_SCAN = "configuration_scan"
    DYNAMIC_SCAN = "dynamic_scan"
    INFRASTRUCTURE_SCAN = "infrastructure_scan"

@dataclass
class Vulnerability:
    """Security vulnerability finding"""
    vuln_id: str
    vuln_type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    code_snippet: Optional[str] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    confidence: float = 1.0
    remediation: Optional[str] = None
    references: List[str] = None
    detected_at: datetime = None
    scan_type: ScanType = ScanType.STATIC_CODE_ANALYSIS
    tool_name: Optional[str] = None
    false_positive: bool = False

    def __post_init__(self):
        if not self.vuln_id:
            self.vuln_id = str(uuid.uuid4())
        if not self.detected_at:
            self.detected_at = datetime.utcnow()
        if not self.references:
            self.references = []

@dataclass
class ScanResult:
    """Security scan result"""
    scan_id: str
    scan_type: ScanType
    target: str
    started_at: datetime
    completed_at: Optional[datetime] = None
    status: str = "running"  # running, completed, failed
    vulnerabilities: List[Vulnerability] = None
    summary: Dict[str, Any] = None
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if not self.scan_id:
            self.scan_id = str(uuid.uuid4())
        if not self.vulnerabilities:
            self.vulnerabilities = []
        if not self.summary:
            self.summary = {}
        if not self.metadata:
            self.metadata = {}

class VulnerabilityScanner:
    """
    Comprehensive vulnerability scanner with OWASP Top 10 coverage
    """

    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}

        # Scanner configuration
        self.enable_bandit = self.config.get('enable_bandit', True)
        self.enable_safety = self.config.get('enable_safety', True)
        self.enable_semgrep = self.config.get('enable_semgrep', True)
        self.enable_custom_rules = self.config.get('enable_custom_rules', True)

        # Scan settings
        self.max_file_size = self.config.get('max_file_size', 10 * 1024 * 1024)  # 10MB
        self.excluded_paths = self.config.get('excluded_paths', [
            '*/node_modules/*', '*/venv/*', '*/.git/*', '*/tests/*'
        ])

        # Custom vulnerability patterns
        self.vulnerability_patterns = self._build_vulnerability_patterns()

        # Remediation templates
        self.remediation_templates = self._build_remediation_templates()

        # Scan results storage
        self._scan_results: Dict[str, ScanResult] = {}

        # Metrics
        self._metrics = {
            "total_scans": 0,
            "vulnerabilities_found": 0,
            "false_positives": 0,
            "vulnerabilities_by_type": {},
            "vulnerabilities_by_severity": {},
            "scan_success_rate": 1.0
        }

        logger.info("VulnerabilityScanner initialized with OWASP Top 10 coverage")

    async def scan_codebase(
        self,
        target_path: str,
        scan_types: List[ScanType] = None
    ) -> ScanResult:
        """Comprehensive codebase security scan"""

        if scan_types is None:
            scan_types = [
                ScanType.STATIC_CODE_ANALYSIS,
                ScanType.DEPENDENCY_SCAN,
                ScanType.CONFIGURATION_SCAN
            ]

        scan_result = ScanResult(
            scan_type=ScanType.STATIC_CODE_ANALYSIS,  # Primary type
            target=target_path,
            started_at=datetime.utcnow(),
            metadata={"scan_types": [st.value for st in scan_types]}
        )

        try:
            self._metrics["total_scans"] += 1

            all_vulnerabilities = []

            # Static code analysis
            if ScanType.STATIC_CODE_ANALYSIS in scan_types:
                static_vulns = await self._run_static_analysis(target_path)
                all_vulnerabilities.extend(static_vulns)

            # Dependency scanning
            if ScanType.DEPENDENCY_SCAN in scan_types:
                dep_vulns = await self._run_dependency_scan(target_path)
                all_vulnerabilities.extend(dep_vulns)

            # Configuration scanning
            if ScanType.CONFIGURATION_SCAN in scan_types:
                config_vulns = await self._run_configuration_scan(target_path)
                all_vulnerabilities.extend(config_vulns)

            # Deduplicate vulnerabilities
            all_vulnerabilities = self._deduplicate_vulnerabilities(all_vulnerabilities)

            # Update scan result
            scan_result.vulnerabilities = all_vulnerabilities
            scan_result.completed_at = datetime.utcnow()
            scan_result.status = "completed"
            scan_result.summary = self._generate_scan_summary(all_vulnerabilities)

            # Update metrics
            self._metrics["vulnerabilities_found"] += len(all_vulnerabilities)
            for vuln in all_vulnerabilities:
                vuln_type = vuln.vuln_type.value
                if vuln_type not in self._metrics["vulnerabilities_by_type"]:
                    self._metrics["vulnerabilities_by_type"][vuln_type] = 0
                self._metrics["vulnerabilities_by_type"][vuln_type] += 1

                severity = vuln.severity.value
                if severity not in self._metrics["vulnerabilities_by_severity"]:
                    self._metrics["vulnerabilities_by_severity"][severity] = 0
                self._metrics["vulnerabilities_by_severity"][severity] += 1

            # Store scan result
            self._scan_results[scan_result.scan_id] = scan_result

            logger.info(
                f"Scan completed: {scan_result.scan_id} - "
                f"{len(all_vulnerabilities)} vulnerabilities found"
            )

            return scan_result

        except Exception as e:
            scan_result.status = "failed"
            scan_result.completed_at = datetime.utcnow()
            scan_result.metadata["error"] = str(e)
            self._scan_results[scan_result.scan_id] = scan_result

            logger.error(f"Scan failed: {e}")
            raise VulnerabilityScanError(f"Scan failed: {str(e)}")

    async def scan_file(self, file_path: str) -> List[Vulnerability]:
        """Scan individual file for vulnerabilities"""
        vulnerabilities = []

        try:
            file_content = await self._read_file_safely(file_path)
            if not file_content:
                return vulnerabilities

            # Custom pattern matching
            pattern_vulns = await self._scan_with_patterns(file_path, file_content)
            vulnerabilities.extend(pattern_vulns)

            # Language-specific analysis
            if file_path.endswith('.py'):
                python_vulns = await self._scan_python_file(file_path, file_content)
                vulnerabilities.extend(python_vulns)
            elif file_path.endswith(('.js', '.ts')):
                js_vulns = await self._scan_javascript_file(file_path, file_content)
                vulnerabilities.extend(js_vulns)
            elif file_path.endswith('.sql'):
                sql_vulns = await self._scan_sql_file(file_path, file_content)
                vulnerabilities.extend(sql_vulns)

            return vulnerabilities

        except Exception as e:
            logger.error(f"File scan failed for {file_path}: {e}")
            return []

    async def get_scan_result(self, scan_id: str) -> Optional[ScanResult]:
        """Get scan result by ID"""
        return self._scan_results.get(scan_id)

    async def get_vulnerability_report(
        self,
        scan_id: str,
        include_false_positives: bool = False
    ) -> Dict[str, Any]:
        """Generate comprehensive vulnerability report"""

        scan_result = self._scan_results.get(scan_id)
        if not scan_result:
            raise VulnerabilityScanError(f"Scan result not found: {scan_id}")

        vulnerabilities = scan_result.vulnerabilities
        if not include_false_positives:
            vulnerabilities = [v for v in vulnerabilities if not v.false_positive]

        # Group vulnerabilities by type and severity
        by_type = {}
        by_severity = {}

        for vuln in vulnerabilities:
            vuln_type = vuln.vuln_type.value
            if vuln_type not in by_type:
                by_type[vuln_type] = []
            by_type[vuln_type].append(vuln)

            severity = vuln.severity.value
            if severity not in by_severity:
                by_severity[severity] = []
            by_severity[severity].append(vuln)

        # Calculate risk score
        risk_score = self._calculate_risk_score(vulnerabilities)

        return {
            "scan_id": scan_id,
            "target": scan_result.target,
            "scan_date": scan_result.started_at.isoformat(),
            "completion_date": scan_result.completed_at.isoformat() if scan_result.completed_at else None,
            "executive_summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_vulnerabilities": len(by_severity.get("critical", [])),
                "high_vulnerabilities": len(by_severity.get("high", [])),
                "medium_vulnerabilities": len(by_severity.get("medium", [])),
                "low_vulnerabilities": len(by_severity.get("low", [])),
                "risk_score": risk_score,
                "risk_level": self._get_risk_level(risk_score)
            },
            "vulnerabilities_by_type": {
                k: len(v) for k, v in by_type.items()
            },
            "vulnerabilities_by_severity": {
                k: len(v) for k, v in by_severity.items()
            },
            "detailed_findings": [asdict(v) for v in vulnerabilities],
            "remediation_priorities": self._get_remediation_priorities(vulnerabilities),
            "owasp_top_10_coverage": self._get_owasp_coverage(vulnerabilities),
            "compliance_impact": self._assess_compliance_impact(vulnerabilities)
        }

    async def mark_false_positive(self, vuln_id: str, reason: str = None) -> bool:
        """Mark vulnerability as false positive"""
        for scan_result in self._scan_results.values():
            for vuln in scan_result.vulnerabilities:
                if vuln.vuln_id == vuln_id:
                    vuln.false_positive = True
                    if reason:
                        vuln.remediation = f"False positive: {reason}"

                    self._metrics["false_positives"] += 1
                    logger.info(f"Vulnerability marked as false positive: {vuln_id}")
                    return True

        return False

    async def get_remediation_guide(
        self,
        vuln_type: VulnerabilityType
    ) -> Dict[str, Any]:
        """Get detailed remediation guide for vulnerability type"""

        return self.remediation_templates.get(vuln_type, {
            "title": f"Remediation for {vuln_type.value}",
            "description": "No specific guidance available",
            "steps": [],
            "references": []
        })

    async def get_metrics(self) -> Dict[str, Any]:
        """Get vulnerability scanning metrics"""
        active_scans = len([
            s for s in self._scan_results.values()
            if s.status == "running"
        ])

        return {
            **self._metrics,
            "active_scans": active_scans,
            "completed_scans": len(self._scan_results) - active_scans
        }

    # Private methods

    async def _run_static_analysis(self, target_path: str) -> List[Vulnerability]:
        """Run static code analysis"""
        vulnerabilities = []

        try:
            # Bandit for Python
            if self.enable_bandit:
                bandit_vulns = await self._run_bandit_scan(target_path)
                vulnerabilities.extend(bandit_vulns)

            # Semgrep for multiple languages
            if self.enable_semgrep:
                semgrep_vulns = await self._run_semgrep_scan(target_path)
                vulnerabilities.extend(semgrep_vulns)

            # Custom pattern analysis
            if self.enable_custom_rules:
                custom_vulns = await self._run_custom_analysis(target_path)
                vulnerabilities.extend(custom_vulns)

        except Exception as e:
            logger.error(f"Static analysis failed: {e}")

        return vulnerabilities

    async def _run_dependency_scan(self, target_path: str) -> List[Vulnerability]:
        """Run dependency vulnerability scan"""
        vulnerabilities = []

        try:
            # Safety for Python dependencies
            if self.enable_safety:
                safety_vulns = await self._run_safety_scan(target_path)
                vulnerabilities.extend(safety_vulns)

            # NPM audit for Node.js dependencies
            npm_vulns = await self._run_npm_audit(target_path)
            vulnerabilities.extend(npm_vulns)

        except Exception as e:
            logger.error(f"Dependency scan failed: {e}")

        return vulnerabilities

    async def _run_configuration_scan(self, target_path: str) -> List[Vulnerability]:
        """Run configuration security scan"""
        vulnerabilities = []

        try:
            # Scan for configuration issues
            config_files = [
                "requirements.txt", "package.json", "Dockerfile",
                "docker-compose.yml", "config.py", "settings.py"
            ]

            for config_file in config_files:
                config_path = Path(target_path) / config_file
                if config_path.exists():
                    config_vulns = await self._scan_configuration_file(str(config_path))
                    vulnerabilities.extend(config_vulns)

        except Exception as e:
            logger.error(f"Configuration scan failed: {e}")

        return vulnerabilities

    async def _run_bandit_scan(self, target_path: str) -> List[Vulnerability]:
        """Run Bandit security scan for Python"""
        vulnerabilities = []

        try:
            # Use bandit programmatically
            b_mgr = manager.BanditManager(
                manager.BanditConfig(),
                "file"
            )

            python_files = list(Path(target_path).rglob("*.py"))

            for py_file in python_files:
                if self._should_exclude_file(str(py_file)):
                    continue

                try:
                    b_mgr.discover_files([str(py_file)])
                    b_mgr.run_tests()

                    for issue in b_mgr.get_issue_list():
                        vuln = Vulnerability(
                            vuln_type=self._map_bandit_test_to_type(issue.test),
                            severity=self._map_bandit_severity(issue.severity),
                            title=f"Bandit: {issue.test}",
                            description=issue.text,
                            file_path=str(py_file),
                            line_number=issue.lineno,
                            code_snippet=issue.get_code(),
                            confidence=self._map_bandit_confidence(issue.confidence),
                            tool_name="bandit",
                            remediation=self._get_bandit_remediation(issue.test)
                        )
                        vulnerabilities.append(vuln)

                except Exception as e:
                    logger.error(f"Bandit scan failed for {py_file}: {e}")

        except Exception as e:
            logger.error(f"Bandit scan setup failed: {e}")

        return vulnerabilities

    async def _run_semgrep_scan(self, target_path: str) -> List[Vulnerability]:
        """Run Semgrep security scan"""
        vulnerabilities = []

        try:
            # Run semgrep command
            cmd = [
                "semgrep",
                "--config=auto",
                "--json",
                "--verbose",
                target_path
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            if process.returncode == 0:
                results = json.loads(stdout.decode())

                for finding in results.get("results", []):
                    vuln = Vulnerability(
                        vuln_type=self._map_semgrep_rule_to_type(finding.get("check_id", "")),
                        severity=self._map_semgrep_severity(finding.get("extra", {}).get("severity", "INFO")),
                        title=f"Semgrep: {finding.get('check_id', 'Unknown')}",
                        description=finding.get("extra", {}).get("message", ""),
                        file_path=finding.get("path"),
                        line_number=finding.get("start", {}).get("line"),
                        code_snippet=finding.get("extra", {}).get("lines", ""),
                        tool_name="semgrep",
                        references=[finding.get("extra", {}).get("metadata", {}).get("source", "")]
                    )
                    vulnerabilities.append(vuln)

        except Exception as e:
            logger.error(f"Semgrep scan failed: {e}")

        return vulnerabilities

    async def _run_safety_scan(self, target_path: str) -> List[Vulnerability]:
        """Run Safety dependency scan for Python"""
        vulnerabilities = []

        try:
            requirements_file = Path(target_path) / "requirements.txt"
            if not requirements_file.exists():
                return vulnerabilities

            # Run safety check
            cmd = [
                "safety", "check",
                "--json",
                "--file", str(requirements_file)
            ]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            if stdout:
                try:
                    results = json.loads(stdout.decode())

                    for vuln_data in results:
                        vuln = Vulnerability(
                            vuln_type=VulnerabilityType.KNOWN_VULNERABILITIES,
                            severity=self._map_safety_severity(vuln_data.get("vulnerability_id")),
                            title=f"Vulnerable dependency: {vuln_data.get('package_name')}",
                            description=vuln_data.get("advisory", ""),
                            file_path=str(requirements_file),
                            tool_name="safety",
                            remediation=f"Update {vuln_data.get('package_name')} to version >= {vuln_data.get('analyzed_version', 'latest')}"
                        )
                        vulnerabilities.append(vuln)

                except json.JSONDecodeError:
                    logger.error("Failed to parse Safety output")

        except Exception as e:
            logger.error(f"Safety scan failed: {e}")

        return vulnerabilities

    async def _run_npm_audit(self, target_path: str) -> List[Vulnerability]:
        """Run NPM audit for Node.js dependencies"""
        vulnerabilities = []

        try:
            package_json = Path(target_path) / "package.json"
            if not package_json.exists():
                return vulnerabilities

            # Run npm audit
            cmd = ["npm", "audit", "--json"]

            process = await asyncio.create_subprocess_exec(
                *cmd,
                cwd=target_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            if stdout:
                try:
                    results = json.loads(stdout.decode())

                    for vuln_id, vuln_data in results.get("vulnerabilities", {}).items():
                        vuln = Vulnerability(
                            vuln_type=VulnerabilityType.KNOWN_VULNERABILITIES,
                            severity=self._map_npm_severity(vuln_data.get("severity")),
                            title=f"NPM vulnerability: {vuln_data.get('name')}",
                            description=vuln_data.get("url", ""),
                            file_path=str(package_json),
                            tool_name="npm_audit",
                            remediation=f"Run 'npm audit fix' or update {vuln_data.get('name')}"
                        )
                        vulnerabilities.append(vuln)

                except json.JSONDecodeError:
                    logger.error("Failed to parse NPM audit output")

        except Exception as e:
            logger.error(f"NPM audit failed: {e}")

        return vulnerabilities

    async def _run_custom_analysis(self, target_path: str) -> List[Vulnerability]:
        """Run custom security analysis"""
        vulnerabilities = []

        try:
            # Scan all files with custom patterns
            for file_path in Path(target_path).rglob("*"):
                if file_path.is_file() and not self._should_exclude_file(str(file_path)):
                    file_vulns = await self.scan_file(str(file_path))
                    vulnerabilities.extend(file_vulns)

        except Exception as e:
            logger.error(f"Custom analysis failed: {e}")

        return vulnerabilities

    async def _scan_with_patterns(
        self,
        file_path: str,
        content: str
    ) -> List[Vulnerability]:
        """Scan file content with vulnerability patterns"""
        vulnerabilities = []

        for vuln_type, patterns in self.vulnerability_patterns.items():
            for pattern_data in patterns:
                pattern = pattern_data["pattern"]
                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)

                for match in matches:
                    line_number = content[:match.start()].count('\n') + 1

                    vuln = Vulnerability(
                        vuln_type=vuln_type,
                        severity=pattern_data["severity"],
                        title=pattern_data["title"],
                        description=pattern_data["description"],
                        file_path=file_path,
                        line_number=line_number,
                        code_snippet=match.group(0),
                        confidence=pattern_data.get("confidence", 0.8),
                        tool_name="custom_patterns",
                        remediation=pattern_data.get("remediation")
                    )
                    vulnerabilities.append(vuln)

        return vulnerabilities

    async def _scan_python_file(
        self,
        file_path: str,
        content: str
    ) -> List[Vulnerability]:
        """Scan Python file for specific vulnerabilities"""
        vulnerabilities = []

        try:
            # Parse AST for more sophisticated analysis
            tree = ast.parse(content)

            # Check for dangerous functions
            dangerous_functions = [
                "eval", "exec", "compile", "__import__",
                "input", "raw_input"  # Python 2
            ]

            for node in ast.walk(tree):
                if isinstance(node, ast.Call):
                    if isinstance(node.func, ast.Name):
                        if node.func.id in dangerous_functions:
                            vuln = Vulnerability(
                                vuln_type=VulnerabilityType.COMMAND_INJECTION,
                                severity=SeverityLevel.HIGH,
                                title=f"Dangerous function: {node.func.id}",
                                description=f"Use of potentially dangerous function {node.func.id}",
                                file_path=file_path,
                                line_number=node.lineno,
                                tool_name="ast_analyzer",
                                remediation=f"Avoid using {node.func.id} with user input"
                            )
                            vulnerabilities.append(vuln)

        except SyntaxError:
            # File might not be valid Python
            pass
        except Exception as e:
            logger.error(f"Python AST analysis failed: {e}")

        return vulnerabilities

    async def _scan_javascript_file(
        self,
        file_path: str,
        content: str
    ) -> List[Vulnerability]:
        """Scan JavaScript file for vulnerabilities"""
        vulnerabilities = []

        # Check for common JS vulnerabilities
        js_patterns = [
            {
                "pattern": r"eval\s*\(",
                "type": VulnerabilityType.COMMAND_INJECTION,
                "severity": SeverityLevel.HIGH,
                "title": "Use of eval()",
                "description": "eval() can execute arbitrary code"
            },
            {
                "pattern": r"innerHTML\s*=\s*.*\+",
                "type": VulnerabilityType.XSS_STORED,
                "severity": SeverityLevel.MEDIUM,
                "title": "Potential XSS via innerHTML",
                "description": "Direct assignment to innerHTML with concatenation"
            },
            {
                "pattern": r"document\.write\s*\(",
                "type": VulnerabilityType.XSS_REFLECTED,
                "severity": SeverityLevel.MEDIUM,
                "title": "Use of document.write()",
                "description": "document.write() can lead to XSS vulnerabilities"
            }
        ]

        for pattern_data in js_patterns:
            matches = re.finditer(pattern_data["pattern"], content, re.IGNORECASE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1

                vuln = Vulnerability(
                    vuln_type=pattern_data["type"],
                    severity=pattern_data["severity"],
                    title=pattern_data["title"],
                    description=pattern_data["description"],
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=match.group(0),
                    tool_name="js_patterns"
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    async def _scan_sql_file(
        self,
        file_path: str,
        content: str
    ) -> List[Vulnerability]:
        """Scan SQL file for vulnerabilities"""
        vulnerabilities = []

        # Check for SQL injection patterns
        sql_patterns = [
            {
                "pattern": r"SELECT\s+.*\s+FROM\s+.*\s+WHERE\s+.*\+",
                "type": VulnerabilityType.SQL_INJECTION,
                "severity": SeverityLevel.HIGH,
                "title": "Potential SQL injection",
                "description": "SQL query uses string concatenation"
            },
            {
                "pattern": r"UNION\s+SELECT",
                "type": VulnerabilityType.SQL_INJECTION,
                "severity": SeverityLevel.MEDIUM,
                "title": "UNION SELECT detected",
                "description": "UNION SELECT may indicate injection vulnerability"
            }
        ]

        for pattern_data in sql_patterns:
            matches = re.finditer(pattern_data["pattern"], content, re.IGNORECASE)
            for match in matches:
                line_number = content[:match.start()].count('\n') + 1

                vuln = Vulnerability(
                    vuln_type=pattern_data["type"],
                    severity=pattern_data["severity"],
                    title=pattern_data["title"],
                    description=pattern_data["description"],
                    file_path=file_path,
                    line_number=line_number,
                    code_snippet=match.group(0),
                    tool_name="sql_patterns"
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    async def _scan_configuration_file(self, file_path: str) -> List[Vulnerability]:
        """Scan configuration file for security issues"""
        vulnerabilities = []

        try:
            content = await self._read_file_safely(file_path)
            if not content:
                return vulnerabilities

            config_patterns = [
                {
                    "pattern": r"password\s*=\s*['\"][^'\"]*['\"]",
                    "type": VulnerabilityType.HARDCODED_SECRETS,
                    "severity": SeverityLevel.HIGH,
                    "title": "Hardcoded password",
                    "description": "Password found in configuration file"
                },
                {
                    "pattern": r"secret\s*=\s*['\"][^'\"]*['\"]",
                    "type": VulnerabilityType.HARDCODED_SECRETS,
                    "severity": SeverityLevel.HIGH,
                    "title": "Hardcoded secret",
                    "description": "Secret key found in configuration file"
                },
                {
                    "pattern": r"DEBUG\s*=\s*True",
                    "type": VulnerabilityType.IMPROPER_ERROR_HANDLING,
                    "severity": SeverityLevel.MEDIUM,
                    "title": "Debug mode enabled",
                    "description": "Debug mode should be disabled in production"
                }
            ]

            for pattern_data in config_patterns:
                matches = re.finditer(pattern_data["pattern"], content, re.IGNORECASE)
                for match in matches:
                    line_number = content[:match.start()].count('\n') + 1

                    vuln = Vulnerability(
                        vuln_type=pattern_data["type"],
                        severity=pattern_data["severity"],
                        title=pattern_data["title"],
                        description=pattern_data["description"],
                        file_path=file_path,
                        line_number=line_number,
                        code_snippet=match.group(0),
                        tool_name="config_scanner"
                    )
                    vulnerabilities.append(vuln)

        except Exception as e:
            logger.error(f"Configuration scan failed for {file_path}: {e}")

        return vulnerabilities

    async def _read_file_safely(self, file_path: str) -> Optional[str]:
        """Safely read file content"""
        try:
            path = Path(file_path)

            if path.stat().st_size > self.max_file_size:
                return None

            with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                return f.read()

        except Exception as e:
            logger.error(f"Failed to read file {file_path}: {e}")
            return None

    def _should_exclude_file(self, file_path: str) -> bool:
        """Check if file should be excluded from scanning"""
        for pattern in self.excluded_paths:
            if pattern.replace('*', '') in file_path:
                return True
        return False

    def _deduplicate_vulnerabilities(
        self,
        vulnerabilities: List[Vulnerability]
    ) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities"""
        seen = set()
        deduplicated = []

        for vuln in vulnerabilities:
            # Create a hash based on type, file, and line
            vuln_hash = hashlib.md5(
                f"{vuln.vuln_type.value}:{vuln.file_path}:{vuln.line_number}".encode()
            ).hexdigest()

            if vuln_hash not in seen:
                seen.add(vuln_hash)
                deduplicated.append(vuln)

        return deduplicated

    def _generate_scan_summary(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Generate scan summary"""
        by_severity = {}
        by_type = {}

        for vuln in vulnerabilities:
            severity = vuln.severity.value
            vuln_type = vuln.vuln_type.value

            if severity not in by_severity:
                by_severity[severity] = 0
            by_severity[severity] += 1

            if vuln_type not in by_type:
                by_type[vuln_type] = 0
            by_type[vuln_type] += 1

        return {
            "total_vulnerabilities": len(vulnerabilities),
            "by_severity": by_severity,
            "by_type": by_type,
            "risk_score": self._calculate_risk_score(vulnerabilities)
        }

    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate overall risk score"""
        if not vulnerabilities:
            return 0.0

        severity_weights = {
            SeverityLevel.CRITICAL: 10,
            SeverityLevel.HIGH: 7,
            SeverityLevel.MEDIUM: 4,
            SeverityLevel.LOW: 2,
            SeverityLevel.INFO: 1
        }

        total_score = sum(
            severity_weights.get(vuln.severity, 1) * vuln.confidence
            for vuln in vulnerabilities
        )

        # Normalize to 0-100 scale
        max_possible = len(vulnerabilities) * 10
        return min(100, (total_score / max_possible) * 100) if max_possible > 0 else 0

    def _get_risk_level(self, risk_score: float) -> str:
        """Get risk level from score"""
        if risk_score < 20:
            return "low"
        elif risk_score < 50:
            return "medium"
        elif risk_score < 80:
            return "high"
        else:
            return "critical"

    def _get_remediation_priorities(
        self,
        vulnerabilities: List[Vulnerability]
    ) -> List[Dict[str, Any]]:
        """Get remediation priorities"""
        # Sort by severity and confidence
        priority_vulns = sorted(
            vulnerabilities,
            key=lambda v: (
                {"critical": 5, "high": 4, "medium": 3, "low": 2, "info": 1}[v.severity.value],
                v.confidence
            ),
            reverse=True
        )

        return [
            {
                "vuln_id": vuln.vuln_id,
                "title": vuln.title,
                "severity": vuln.severity.value,
                "file_path": vuln.file_path,
                "remediation": vuln.remediation
            }
            for vuln in priority_vulns[:10]  # Top 10 priorities
        ]

    def _get_owasp_coverage(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Get OWASP Top 10 coverage analysis"""
        owasp_categories = {
            "A01_Broken_Access_Control": [
                VulnerabilityType.BROKEN_ACCESS_CONTROL,
                VulnerabilityType.INSECURE_DIRECT_OBJECT_REFERENCE,
                VulnerabilityType.MISSING_AUTHORIZATION
            ],
            "A02_Cryptographic_Failures": [
                VulnerabilityType.WEAK_ENCRYPTION,
                VulnerabilityType.HARDCODED_SECRETS,
                VulnerabilityType.INSECURE_RANDOM,
                VulnerabilityType.WEAK_HASHING
            ],
            "A03_Injection": [
                VulnerabilityType.SQL_INJECTION,
                VulnerabilityType.NOSQL_INJECTION,
                VulnerabilityType.COMMAND_INJECTION,
                VulnerabilityType.LDAP_INJECTION,
                VulnerabilityType.XSS_STORED,
                VulnerabilityType.XSS_REFLECTED
            ]
            # Add other OWASP categories as needed
        }

        coverage = {}
        for category, vuln_types in owasp_categories.items():
            found_vulns = [
                v for v in vulnerabilities
                if v.vuln_type in vuln_types
            ]
            coverage[category] = {
                "count": len(found_vulns),
                "severity_breakdown": {
                    severity.value: len([v for v in found_vulns if v.severity == severity])
                    for severity in SeverityLevel
                }
            }

        return coverage

    def _assess_compliance_impact(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Assess compliance impact of vulnerabilities"""
        pii_related = [
            v for v in vulnerabilities
            if "pii" in v.description.lower() or "personal" in v.description.lower()
        ]

        return {
            "gdpr_impact": len(pii_related) > 0,
            "pci_dss_impact": any(
                v.vuln_type in [
                    VulnerabilityType.WEAK_ENCRYPTION,
                    VulnerabilityType.HARDCODED_SECRETS
                ]
                for v in vulnerabilities
            ),
            "sox_impact": any(
                v.severity == SeverityLevel.CRITICAL
                for v in vulnerabilities
            ),
            "recommendations": [
                "Review data handling practices for GDPR compliance",
                "Implement proper encryption for sensitive data",
                "Establish security controls for financial data"
            ]
        }

    def _build_vulnerability_patterns(self) -> Dict[VulnerabilityType, List[Dict[str, Any]]]:
        """Build comprehensive vulnerability patterns"""
        return {
            VulnerabilityType.SQL_INJECTION: [
                {
                    "pattern": r"execute\s*\(\s*[\"'].*%s.*[\"']",
                    "severity": SeverityLevel.HIGH,
                    "title": "SQL Injection via string formatting",
                    "description": "SQL query uses string formatting which can lead to injection",
                    "confidence": 0.9,
                    "remediation": "Use parameterized queries or prepared statements"
                },
                {
                    "pattern": r"cursor\.execute\s*\([^)]*format\(",
                    "severity": SeverityLevel.HIGH,
                    "title": "SQL Injection via format()",
                    "description": "SQL query uses .format() which can lead to injection",
                    "confidence": 0.8,
                    "remediation": "Use parameterized queries instead of string formatting"
                }
            ],
            VulnerabilityType.XSS_REFLECTED: [
                {
                    "pattern": r"innerHTML\s*=\s*.*\+",
                    "severity": SeverityLevel.MEDIUM,
                    "title": "Potential XSS via innerHTML",
                    "description": "Direct assignment to innerHTML with concatenation",
                    "confidence": 0.7,
                    "remediation": "Use textContent or properly escape HTML content"
                }
            ],
            VulnerabilityType.HARDCODED_SECRETS: [
                {
                    "pattern": r"password\s*=\s*['\"][^'\"]{8,}['\"]",
                    "severity": SeverityLevel.HIGH,
                    "title": "Hardcoded password",
                    "description": "Password appears to be hardcoded in source code",
                    "confidence": 0.8,
                    "remediation": "Store passwords in environment variables or secure vaults"
                },
                {
                    "pattern": r"api[_-]?key\s*=\s*['\"][^'\"]{20,}['\"]",
                    "severity": SeverityLevel.HIGH,
                    "title": "Hardcoded API key",
                    "description": "API key appears to be hardcoded in source code",
                    "confidence": 0.9,
                    "remediation": "Store API keys in environment variables"
                }
            ]
        }

    def _build_remediation_templates(self) -> Dict[VulnerabilityType, Dict[str, Any]]:
        """Build remediation templates"""
        return {
            VulnerabilityType.SQL_INJECTION: {
                "title": "SQL Injection Remediation",
                "description": "Steps to fix SQL injection vulnerabilities",
                "steps": [
                    "Use parameterized queries or prepared statements",
                    "Validate and sanitize all user inputs",
                    "Implement proper error handling",
                    "Use stored procedures where appropriate",
                    "Apply principle of least privilege to database connections"
                ],
                "references": [
                    "https://owasp.org/www-community/attacks/SQL_Injection",
                    "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                ]
            },
            VulnerabilityType.XSS_REFLECTED: {
                "title": "Cross-Site Scripting (XSS) Remediation",
                "description": "Steps to prevent XSS attacks",
                "steps": [
                    "Encode all user-supplied data before output",
                    "Use Content Security Policy (CSP) headers",
                    "Validate input on both client and server side",
                    "Use safe DOM manipulation methods",
                    "Implement proper session management"
                ],
                "references": [
                    "https://owasp.org/www-community/attacks/xss/",
                    "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
                ]
            }
        }

    # Mapping methods for different tools

    def _map_bandit_test_to_type(self, test_name: str) -> VulnerabilityType:
        """Map Bandit test to vulnerability type"""
        mapping = {
            "B101": VulnerabilityType.WEAK_HASHING,  # assert_used
            "B102": VulnerabilityType.COMMAND_INJECTION,  # exec_used
            "B103": VulnerabilityType.IMPROPER_ERROR_HANDLING,  # set_bad_file_permissions
            "B104": VulnerabilityType.HARDCODED_SECRETS,  # hardcoded_bind_all_interfaces
            "B105": VulnerabilityType.HARDCODED_SECRETS,  # hardcoded_password_string
            "B106": VulnerabilityType.HARDCODED_SECRETS,  # hardcoded_password_funcarg
            "B107": VulnerabilityType.HARDCODED_SECRETS,  # hardcoded_password_default
        }
        return mapping.get(test_name, VulnerabilityType.INSECURE_DESIGN)

    def _map_bandit_severity(self, severity: str) -> SeverityLevel:
        """Map Bandit severity to our severity levels"""
        mapping = {
            "LOW": SeverityLevel.LOW,
            "MEDIUM": SeverityLevel.MEDIUM,
            "HIGH": SeverityLevel.HIGH
        }
        return mapping.get(severity.upper(), SeverityLevel.MEDIUM)

    def _map_bandit_confidence(self, confidence: str) -> float:
        """Map Bandit confidence to float"""
        mapping = {
            "LOW": 0.3,
            "MEDIUM": 0.6,
            "HIGH": 0.9
        }
        return mapping.get(confidence.upper(), 0.5)

    def _map_semgrep_rule_to_type(self, rule_id: str) -> VulnerabilityType:
        """Map Semgrep rule ID to vulnerability type"""
        if "sql" in rule_id.lower():
            return VulnerabilityType.SQL_INJECTION
        elif "xss" in rule_id.lower():
            return VulnerabilityType.XSS_REFLECTED
        elif "secret" in rule_id.lower() or "key" in rule_id.lower():
            return VulnerabilityType.HARDCODED_SECRETS
        else:
            return VulnerabilityType.INSECURE_DESIGN

    def _map_semgrep_severity(self, severity: str) -> SeverityLevel:
        """Map Semgrep severity to our severity levels"""
        mapping = {
            "ERROR": SeverityLevel.HIGH,
            "WARNING": SeverityLevel.MEDIUM,
            "INFO": SeverityLevel.LOW
        }
        return mapping.get(severity.upper(), SeverityLevel.MEDIUM)

    def _map_safety_severity(self, vuln_id: str) -> SeverityLevel:
        """Map Safety vulnerability to severity level"""
        # Safety doesn't provide severity, so we estimate based on vulnerability ID
        return SeverityLevel.HIGH  # Default to high for known vulnerabilities

    def _map_npm_severity(self, severity: str) -> SeverityLevel:
        """Map NPM severity to our severity levels"""
        mapping = {
            "critical": SeverityLevel.CRITICAL,
            "high": SeverityLevel.HIGH,
            "moderate": SeverityLevel.MEDIUM,
            "low": SeverityLevel.LOW,
            "info": SeverityLevel.INFO
        }
        return mapping.get(severity.lower(), SeverityLevel.MEDIUM)

    def _get_bandit_remediation(self, test_name: str) -> str:
        """Get remediation advice for Bandit test"""
        remediations = {
            "B101": "Avoid using assert statements for data validation in production",
            "B102": "Avoid using exec() and eval() with user input",
            "B105": "Avoid hardcoding passwords in source code",
            "B106": "Avoid passing passwords as function arguments",
            "B107": "Avoid using hardcoded passwords as default values"
        }
        return remediations.get(test_name, "Review code for security implications")

class VulnerabilityScanError(Exception):
    """Vulnerability scanning exception"""
    pass