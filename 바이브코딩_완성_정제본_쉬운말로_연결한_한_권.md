# 바이브코딩 완성 정제본 — 쉬운말로 연결한 한 권

> 강의 중간중간 적은 메모와 원문을 **쉬운말만으로** 자연스럽게 이어 붙여, 외우지 않아도 바로 실행 가능한 “바이블”로 재구성했습니다.  
> 코드·아키텍처·운용 예시를 **구체 스택**(TypeScript/NestJS, Python/FastAPI, PostgreSQL, Kafka, OpenAPI, GitHub Actions, Playwright, Sentry 등)와 함께 넣었습니다.

---

## 0) 이 문서가 약속하는 것
- **혼선(엔트로피)을 줄이고**, **정보이득(IG)을 높이는** 방식으로 코딩 흐름을 표준화합니다.
- **코드가 단일 진실(SOT)**이라는 원칙을 지키면서, 문서는 **계약과 증거**를 담는 보조물로만 씁니다.
- **설명→코드** 순서, **작은 커밋(≤5파일)**, **증거 기반 검증**이 기본입니다.

---

## 1) 기본 철학: “혼선↓, 정보이득↑”
1. **혼선은 적의 이름**: 모호한 말(‘적절히/아마도/일반적으로’)이 끼면 오류 확률이 폭증합니다. 문장을 수치·조건·규칙으로 바꾸세요.
2. **정보이득 임계치**: 실행 전에 “지금 정보로 모호함이 충분히 줄었는가?”를 확인합니다. 미달이면 **보류(Abstain)**하고 필요한 정보를 먼저 모읍니다.
3. **코드가 진실**: 문서/주석과 코드가 다르면 **코드를 기준**으로 맞춥니다. 문서는 **스키마·시그널·리포트**처럼 코드를 돕는 자료여야 합니다.
4. **발산 최소화**: 아이디에이션을 했다면 **결과만 남기고 새 대화**에서 다시 시작합니다. 생략어·은유어를 걷어내고 계약과 예시로 닫습니다.
5. **입력 ≥ 출력×20**: 모델에게 주는 입력(맥락)이 출력보다 충분히 많아야 결과가 안정됩니다. 초반엔 **“짧게 답해/아직 코드는 쓰지 마”**로 출력을 억제하세요.

---

## 2) 모델이 헛소리(할루시네이션)를 하는 세 가지 이유와 처방
- **A. 모델 한계형**: 모델 자체 해상도 부족 → **더 나은 모델/도구**, **RAG**, **스키마 검증(zod/pydantic)**, **외부 툴**로 보완.
- **B. 온도형**: 자연스러움↑ ↔ 정확성↓ → **온도/탑P 낮춤**, 답변을 **짧고 구조화**.
- **C. 입력 불확실형**: 빈칸이 많아 추측 발생 → **타입/스키마/경계조건/반례 예시**로 빈칸을 닫음.

> 빠른 자가진단: 모호어가 보이면 **정지**. 파일·함수·에러메시지 등 **구체 인용**이 나오면 **진행**.

---

## 3) 컨텍스트를 올바르게 싣는 법
### 3.1 Main vs Reference 디렉터리
- **Main**: 지금 우리가 수정/구현할 폴더.
- **Reference**: 다른 팀/리포/서비스. **내부 구현을 보지 말고, 인터페이스(계약)만** 사용합니다.

### 3.2 도메인 간에는 “시그널 한 장”
- **원칙**: **의도(kind) + 이름/버전 + payload(필수 데이터 전부) + correlationId + (선택) idempotencyKey/ttl/schemaRef**.  
  수신자는 **이 신호만으로 처리**할 수 있어야 합니다(재조회 금지).

#### TypeScript 예시 (NestJS)
```ts
// contracts/signal.ts
export type SignalKind = "Command" | "Query" | "Event";
export interface Signal<T> {
  kind: SignalKind; name: string; version: string;
  source: string; target: string; correlationId: string;
  idempotencyKey?: string; ttl?: number; schemaRef?: string;
  payload: T; // Self-contained 데이터
}

// CreateOrder.v1
export interface CreateOrderV1 {
  orderId: string;
  customer: { id: string; tier: "gold"|"silver"|"bronze" };
  items: { sku: string; qty: number; unitPrice: number }[];
  currency: "KRW" | "USD";
  requestedAt: string; // ISO8601
}
```

#### Python 예시 (FastAPI + pydantic)
```python
from pydantic import BaseModel
from typing import Literal, List

class Signal(BaseModel):
    kind: Literal["Command","Query","Event"]
    name: str; version: str; source: str; target: str
    correlationId: str; idempotencyKey: str | None = None
    ttl: int | None = None; schemaRef: str | None = None
    payload: dict

class CreateOrderV1(BaseModel):
    orderId: str
    customer: dict  # {"id": str, "tier": "gold"|"silver"|"bronze"}
    items: List[dict]  # [{"sku": str, "qty": int, "unitPrice": float}]
    currency: Literal["KRW","USD"]
    requestedAt: str
```

---

## 4) 리포가 여러 개일 때(Inter-repo)
### 4.1 최선은 모노레포
컨테이너/워크스페이스로 하나로 묶으면 버전·스키마·코드가 **한 커밋**에서 움직여 참조 오류가 줄어듭니다.

### 4.2 멀티레포라면 “계약 패키지”로 동기화
```
/interrepo-package
  MANIFEST.json         # 도착지 정보/버전/커밋/연락처
  openapi.yaml          # 또는 proto / json schema
  examples/requests/*.json
  examples/responses/*.json
  changelog.md
```
**MANIFEST.json 예시**
```json
{
  "sourceRepo": "checkout",
  "destinationRepo": "order",
  "schemaFile": "openapi.yaml",
  "schemaVersion": "v1.3.2",
  "apiBaseUrlHint": "https://api-order.example.com",
  "commit": "c9a42b1",
  "contact": { "team": "checkout", "slack": "#checkout-api" }
}
```

### 4.3 계약→코드 자동생성
```bash
# TypeScript SDK
openapi-generator-cli generate -i openapi.yaml -g typescript-fetch -o clients/ts
# Python 클라이언트
openapi-generator-cli generate -i openapi.yaml -g python -o clients/py
```

---

## 5) 테스트·검증·관측은 기본값
- **테스트코드 필수**: 단위(Jest/pytest) / 통합 / E2E(Playwright) 분리.
- **CI/CD 검증 시나리오**: PR마다 린트·타입·테스트·컨트랙트 테스트를 자동 실행.
- **모바일 자동화**: Fastlane, Firebase Test Lab로 기기별 리그레션.
- **관측/디버깅**: **Sentry**에 재현 절차/기대vs실제/로그/가설/다음 실험을 남기는 양식으로 기록.

#### GitHub Actions 예시
```yaml
name: ci
on: [pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }
      - run: npm ci
      - run: npm run lint && npm run typecheck && npm test -- --ci
      - run: npm run contract:test  # OpenAPI 스키마 검증/호환성
```

#### Playwright E2E 예시
```ts
import { test, expect } from '@playwright/test';

test('로그인 후 주문 가능', async ({ page }) => {
  await page.goto('http://localhost:3000');
  await page.getByLabel('email').fill('gold@example.com');
  await page.getByLabel('password').fill('secret');
  await page.getByRole('button', { name: '로그인' }).click();
  await expect(page.getByText('안녕하세요')).toBeVisible();
});
```

---

## 6) 표준 아키텍처와 템플릿
- **가능하면 템플릿 사용**: NestJS(백엔드)/Next.js(프론트)/FastAPI(서비스) 등 검증된 골격.
- **레거시라면 패턴 표준화**: 일관성 없는 부분은 **Façade**를 앞에 세우고, 내부는 **블랙박스화**한 뒤 바깥에서 사용.
- **전략 선택(정보이득×복잡도 사분면)**
  - **높은 IG × 낮은 복잡도**: 즉시 정화(바로 개선).
  - **높은 IG × 높은 복잡도**: 단계적 정화(계획적으로 나눔).
  - **낮은 IG × 낮은 복잡도**: 블랙박스화(겉 인터페이스만 사용).
  - **낮은 IG × 높은 복잡도**: 완전 격리(의존 끊기).

---

## 7) 레거시 대응 플레이북
1) **목적 확인**(왜 고치는가) → 2) **아키텍처 패턴** 파악 → 3) **디렉터리/의존 트리** 보기  
4) **Façade 위치**를 정하고 그 **인터페이스만 노출** → 5) 나머지는 **명세/시그널**로 분리  
6) **테스트**로 안전망 만들고 → 7) **작은 커밋**으로 단계적 정화.

---

## 8) 팀 운영 규칙(강제 장치로 습관화)
- **PR 체크리스트**
  - [ ] 커밋당 변경 파일 ≤ 5
  - [ ] “설명 10줄” 승인 후 구현 시작
  - [ ] DoD(린트/타입/테스트/성능·보안 수치) 충족
  - [ ] SOT=코드 유지(장문 주석 금지, 계약/시그널 갱신)
- **커밋 훅**: 변경 파일 수 초과 시 푸시 차단.
- **CI 필수 단계**: 스키마 검증, 타입체크, 컨트랙트 테스트, E2E 스모크.

---

## 9) AI 운용 원칙
- **Automation vs Augmentation**: 확실한 반복은 자동화, 모호한 설계/통합은 사람이 주도하고 AI가 보조.
- **모델 스위칭은 경계에서만**: 루프 중간 교체는 혼선을 키움. 루프 끝(검증 완료 시점)에 평가 후 교체.
- **멀티 에이전트는 과제에 맞게**: 역할이 명확하고 계약이 있는 경우에만 이점이 큼.

---

## 10) 트렌드 대응 전략(모델/에이전트/프레임워크)
- 새 도구가 나올 때 선택지는 **무시 계속 / 완전 재시작 / 점진적 적응**.  
- 원칙: **비즈니스 목적·제약·품질 기준**으로 비교표를 만들고, **점진적 적응**을 1순위로 검토.

---

## 11) 즉시 쓰는 시나리오 4종
### A) 새 백엔드 엔드포인트 추가 (NestJS)
1. `openapi.yaml`에 경로/요청/응답/에러 정의  
2. `controller → service → repository` 뼈대 생성  
3. **시그널/DTO**로 self-contained 보장  
4. Jest 단위 테스트 + Playwright 스모크  
5. GitHub Actions에서 계약·타입·테스트 통과 확인

### B) FastAPI 서비스 통합 (Python)
- Pydantic 모델로 요청/응답 계약을 명시 → 시그널 수신 핸들러 작성 → 컨슈머(Kafka)로 이벤트 브로드캐스트 → pytest로 경계 테스트.

### C) Inter-repo 연동
- 계약 패키지 수신(MANIFEST 포함) → 오토제너레이터로 SDK/타입 갱신 → 컨트랙트 테스트로 호환성 확인.

### D) 모바일 자동화 리그레션
- Fastlane 스크립트와 Firebase Test Lab 조합으로 주요 시나리오를 기기 매트릭스에서 병렬 검증.

---

## 12) 템플릿 모음 (복붙해서 쓰기)
**A. Context Sheet**
```
문제정의 / 목표 / 비범위
입출력(스키마 링크) / 제약(성능·보안 수치)
에러 경계 / 테스트 후보 / IG 부족 항목
```

**B. 시그널 스키마(예: 주문 생성)**
```json
{
  "kind": "Command",
  "name": "CreateOrder",
  "version": "v1",
  "source": "checkout",
  "target": "order",
  "correlationId": "...",
  "idempotencyKey": "create-order-O-101",
  "payload": {
    "orderId": "O-101",
    "customer": { "id": "C-77", "tier": "gold" },
    "items": [ { "sku": "SKU-1", "qty": 2, "unitPrice": 12000 } ],
    "currency": "KRW",
    "requestedAt": "2025-10-01T02:30:00Z"
  }
}
```

**C. MANIFEST.json**
```json
{ "sourceRepo": "checkout", "destinationRepo": "order", "schemaFile": "openapi.yaml", "schemaVersion": "v1.3.2", "commit": "c9a42b1" }
```

**D. PR 체크리스트**
```
[ ] 변경 파일 ≤ 5
[ ] 설명 10줄 승인 → 구현 시작
[ ] DoD 충족: lint/type/test/contract/e2e
[ ] 시그널·스키마 갱신
```

**E. OAuth2 + Rate limiting (NestJS 예시)**
```ts
// ThrottlerModule.forRoot({ ttl: 60, limit: 100 })
// OAuth2는 gateway/proxy 또는 Nest guard로 연동
```

**F. Postgres 인덱스 최적화 체크**
```
실행 계획(Explain Analyze) 확인 → 불필요한 Seq Scan 제거 → 조인 키/필터에 맞춘 인덱스 추가 → 100ms 목표
```

---

## 13) 기억 카드
- **코드는 진실, 문서는 계약과 증거**
- **설명→코드**, **작은 커밋**, **입력≥출력×20**
- **시그널 한 장**으로 도메인 간 오해 금지
- **계약 패키지**로 멀티레포 동기화
- **테스트/CI/Sentry**는 기본값


# 바이브코딩 — 체크리스트 에디션

> 실행 직전/PR 직전/릴리스 직전마다 훑어보는 실무용 체크리스트입니다.

## 1) 시작 전 공통 (IG 임계치)
- [ ] 목적/가치/제약/비범위가 문서화되어 있다 (Scope)
- [ ] 모호어 제거(‘적절히/아마도/일반적으로’ → 수치/조건)
- [ ] 입력(맥락) ≥ 출력(생성)×20 유지 계획
- [ ] “짧게 답해 / 아직 코드는 쓰지 마” 운용 동의
- [ ] SOT=코드(문서/주석이 코드와 충돌 시 코드 기준)

## 2) 컨텍스트 로딩
- [ ] Main vs Reference 디렉터리 분리
- [ ] Reference는 **인터페이스/스키마/DTO/Port**만 읽었다
- [ ] 도메인 간 **시그널 Self-contained** 확인(재조회 금지)
- [ ] 파일/함수/스키마/설정 경로를 정확히 지정
- [ ] 위험 신호(모호어/장황설명/3줄↑ 주석) 발견 시 **Abstain**

## 3) 시그널(도메인 간) 필수 필드
- [ ] kind(name/version 포함)
- [ ] payload(필수 데이터 전부)
- [ ] correlationId
- [ ] (선택) idempotencyKey / ttl / schemaRef
- [ ] 수신 도메인이 **신호만으로 처리 가능**함을 테스트

## 4) Inter-repo 동기화
- [ ] 모노레포가 아니면 **계약 패키지**를 수신/배포
- [ ] MANIFEST.json에 **source/destination/버전/커밋/연락처** 포함
- [ ] OpenAPI/Proto/JSON-Schema로 계약 고정
- [ ] SDK/타입 **자동생성** 파이프라인 동작 확인
- [ ] md만으로 참조하지 않음

## 5) 7-Stage 루프
- [ ] Scope 작성
- [ ] Context Load(2-depth, MI 높은 것부터)
- [ ] Synthesis(Context Sheet 완성)
- [ ] Plan(≤5파일, DoD: lint/type/test/perf/security)
- [ ] Explain(알고리즘 10줄 승인)
- [ ] Implement(린트/타입 통과)
- [ ] Verify(테스트·리포트) → Cleanup

## 6) 테스트/검증/관측
- [ ] 단위(Jest/pytest) / 통합 / E2E(Playwright) 준비
- [ ] PR마다 린트·타입·테스트·컨트랙트 테스트 자동 실행
- [ ] Sentry 리포트 포맷(재현/기대vs실제/로그/가설/다음실험) 유지

## 7) 팀 강제 장치
- [ ] PR 체크리스트(≤5파일, 설명 10줄, DoD, SOT=코드) 통과
- [ ] 커밋 훅(파일 수 초과 차단) 설정
- [ ] CI: 스키마 검증/타입체크/컨트랙트/E2E 스모크

## 8) 스택별 빠른 점검
### NestJS
- [ ] `openapi.yaml`에 경로/요청/응답/에러 정의
- [ ] `controller → service → repository` 뼈대 생성
- [ ] DTO/시그널 Self-contained 확인
- [ ] Jest 단위 테스트, Playwright 스모크

### FastAPI
- [ ] Pydantic 모델(요청/응답) 정의
- [ ] 시그널 수신 핸들러 작성, Kafka/이벤트 브로드캐스트
- [ ] pytest 경계 테스트

### PostgreSQL
- [ ] Explain Analyze 점검
- [ ] Seq Scan 제거, 조인 키/필터 인덱스
- [ ] p95 < 100ms 목표

## 9) 레거시 대응
- [ ] 목적 확인 → 패턴 파악 → 의존 트리
- [ ] Façade 노출, 내부 블랙박스화
- [ ] 테스트 안전망 → 작은 커밋으로 정화

## 10) AI 운용
- [ ] Automation vs Augmentation 분기 결정
- [ ] 모델 스위칭은 루프 경계에서만
- [ ] 모호어 발견 시 **Abstain** → 정보 보강 후 재시도
