#!/usr/bin/env python3
"""
DT-RAG Production System Test Script
Ïã§Ï†ú PostgreSQL + pgvector Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ÏùÑ Í≤ÄÏ¶ùÌïòÍ≥†
Î™®Îì† ÌïµÏã¨ Í∏∞Îä•ÏùÑ ÌÖåÏä§Ìä∏Ìï©ÎãàÎã§.
"""

import asyncio
import json
import sys
import time
from pathlib import Path
from typing import Dict, Any, List

# ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏Î•º sys.pathÏóê Ï∂îÍ∞Ä
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

class ProductionSystemTester:
    """ÌîÑÎ°úÎçïÏÖò ÏãúÏä§ÌÖú Ï¢ÖÌï© ÌÖåÏä§ÌÑ∞"""

    def __init__(self):
        self.test_results = {}
        self.start_time = time.time()

    async def test_database_connection(self) -> bool:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏"""
        print("üîå Testing Database Connection...")

        try:
            from apps.api.database import test_database_connection, db_manager
            from sqlalchemy import text

            # Í∏∞Î≥∏ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
            connected = await test_database_connection()
            if not connected:
                self.test_results["database_connection"] = {
                    "status": "FAIL",
                    "error": "Basic connection test failed"
                }
                return False

            # pgvector ÌôïÏû• ÌôïÏù∏
            async with db_manager.async_session() as session:
                try:
                    result = await session.execute(
                        text("SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname = 'vector')")
                    )
                    has_pgvector = result.scalar()

                    if not has_pgvector:
                        print("   ‚ö†Ô∏è pgvector extension not found")
                        self.test_results["database_connection"] = {
                            "status": "PARTIAL",
                            "warning": "pgvector extension missing"
                        }
                        return True  # Í∏∞Î≥∏ Ïó∞Í≤∞ÏùÄ ÏûëÎèô

                    print("   ‚úÖ pgvector extension found")

                except Exception as e:
                    print(f"   ‚ö†Ô∏è pgvector check failed: {e}")

                # ÌÖåÏù¥Î∏î Ï°¥Ïû¨ ÌôïÏù∏
                tables_to_check = ['documents', 'taxonomy', 'search_logs']
                existing_tables = []

                for table in tables_to_check:
                    try:
                        result = await session.execute(
                            text(f"SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name = '{table}')")
                        )
                        if result.scalar():
                            existing_tables.append(table)
                    except Exception:
                        pass

                print(f"   üìã Tables found: {', '.join(existing_tables)}")

            self.test_results["database_connection"] = {
                "status": "PASS",
                "pgvector_enabled": has_pgvector,
                "tables_found": existing_tables
            }

            return True

        except Exception as e:
            self.test_results["database_connection"] = {
                "status": "FAIL",
                "error": str(e)
            }
            print(f"   ‚ùå Connection test failed: {e}")
            return False

    async def test_document_operations(self) -> bool:
        """Î¨∏ÏÑú CRUD ÏûëÏóÖ ÌÖåÏä§Ìä∏"""
        print("\nüìÑ Testing Document Operations...")

        try:
            from apps.api.database import db_manager
            from sqlalchemy import text

            async with db_manager.async_session() as session:
                # Î¨∏ÏÑú Ï°∞Ìöå ÌÖåÏä§Ìä∏
                query = text("SELECT COUNT(*) FROM documents")
                result = await session.execute(query)
                doc_count = result.scalar()

                print(f"   üìä Total documents in database: {doc_count}")

                if doc_count == 0:
                    print("   ‚ö†Ô∏è No documents found - inserting test document")

                    # ÌÖåÏä§Ìä∏ Î¨∏ÏÑú ÏÇΩÏûÖ
                    insert_query = text("""
                        INSERT INTO documents (title, content, metadata)
                        VALUES (:title, :content, :metadata)
                        RETURNING id
                    """)

                    result = await session.execute(insert_query, {
                        "title": "Test Document",
                        "content": "This is a test document for DT-RAG system validation.",
                        "metadata": json.dumps({"test": True, "created_by": "test_script"})
                    })

                    doc_id = result.scalar()
                    await session.commit()

                    print(f"   ‚úÖ Test document created with ID: {doc_id}")

                # ÏµúÍ∑º Î¨∏ÏÑú Ï°∞Ìöå
                recent_docs_query = text("""
                    SELECT id, title, content, created_at
                    FROM documents
                    ORDER BY created_at DESC
                    LIMIT 3
                """)

                result = await session.execute(recent_docs_query)
                recent_docs = result.fetchall()

                print(f"   üìã Recent documents:")
                for doc in recent_docs:
                    print(f"      - {doc[0]}: '{doc[1][:50]}...'")

            self.test_results["document_operations"] = {
                "status": "PASS",
                "total_documents": doc_count + (1 if doc_count == 0 else 0),
                "recent_documents": len(recent_docs)
            }

            return True

        except Exception as e:
            self.test_results["document_operations"] = {
                "status": "FAIL",
                "error": str(e)
            }
            print(f"   ‚ùå Document operations test failed: {e}")
            return False

    async def test_search_functionality(self) -> bool:
        """Í≤ÄÏÉâ Í∏∞Îä• ÌÖåÏä§Ìä∏"""
        print("\nüîç Testing Search Functionality...")

        try:
            from apps.api.database import SearchDAO

            test_queries = [
                "DT-RAG system",
                "vector embeddings",
                "test document"
            ]

            search_results = {}

            for query in test_queries:
                print(f"   Testing query: '{query}'")

                start_time = time.time()
                results = await SearchDAO.hybrid_search(
                    query=query,
                    topk=5
                )
                search_time = (time.time() - start_time) * 1000

                print(f"   üîç Found {len(results)} results in {search_time:.2f}ms")

                if results:
                    top_result = results[0]
                    print(f"   üìÑ Top result: '{top_result['title']}'")
                    print(f"   üìä Score: {top_result['score']:.3f}")

                    metadata = top_result.get('metadata', {})
                    if 'bm25_score' in metadata and 'vector_score' in metadata:
                        print(f"   üìà BM25: {metadata['bm25_score']:.3f}, Vector: {metadata['vector_score']:.3f}")

                search_results[query] = {
                    "result_count": len(results),
                    "search_time_ms": search_time,
                    "has_results": len(results) > 0
                }

            all_searches_working = all(result["has_results"] for result in search_results.values())

            self.test_results["search_functionality"] = {
                "status": "PASS" if all_searches_working else "PARTIAL",
                "search_results": search_results,
                "total_queries_tested": len(test_queries)
            }

            return True

        except Exception as e:
            self.test_results["search_functionality"] = {
                "status": "FAIL",
                "error": str(e)
            }
            print(f"   ‚ùå Search functionality test failed: {e}")
            return False

    async def test_classification_system(self) -> bool:
        """Î∂ÑÎ•ò ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏"""
        print("\nüè∑Ô∏è Testing Classification System...")

        try:
            from apps.api.database import ClassifyDAO

            test_texts = [
                "This document discusses RAG systems and vector search technology.",
                "Machine learning algorithms are used for document classification.",
                "The taxonomy system organizes documents hierarchically."
            ]

            classification_results = {}

            for text in test_texts:
                print(f"   Classifying: '{text[:60]}...'")

                start_time = time.time()
                result = await ClassifyDAO.classify_text(text)
                classify_time = (time.time() - start_time) * 1000

                print(f"   üè∑Ô∏è Category: {result['label']}")
                print(f"   üìä Confidence: {result['confidence']:.3f}")
                print(f"   üõ£Ô∏è Path: {' ‚Üí '.join(result['canonical'])}")
                print(f"   ‚è±Ô∏è Time: {classify_time:.2f}ms")

                classification_results[text[:30] + "..."] = {
                    "label": result['label'],
                    "confidence": result['confidence'],
                    "path": result['canonical'],
                    "classify_time_ms": classify_time
                }

            avg_confidence = sum(r["confidence"] for r in classification_results.values()) / len(classification_results)

            self.test_results["classification_system"] = {
                "status": "PASS",
                "classification_results": classification_results,
                "average_confidence": avg_confidence,
                "total_texts_classified": len(test_texts)
            }

            return True

        except Exception as e:
            self.test_results["classification_system"] = {
                "status": "FAIL",
                "error": str(e)
            }
            print(f"   ‚ùå Classification system test failed: {e}")
            return False

    async def test_taxonomy_system(self) -> bool:
        """Î∂ÑÎ•òÏ≤¥Í≥Ñ ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏"""
        print("\nüå≥ Testing Taxonomy System...")

        try:
            from apps.api.database import TaxonomyDAO

            # Í∏∞Î≥∏ Î∂ÑÎ•òÏ≤¥Í≥Ñ Ï°∞Ìöå
            taxonomy_tree = await TaxonomyDAO.get_tree("1")

            print(f"   üìä Taxonomy nodes found: {len(taxonomy_tree)}")

            if taxonomy_tree:
                print("   üå≥ Taxonomy structure:")
                for node in taxonomy_tree[:3]:  # ÏÉÅÏúÑ 3Í∞úÎßå ÌëúÏãú
                    path_str = " ‚Üí ".join(node.get("canonical_path", []))
                    print(f"      {node.get('label', 'Unknown')}: {path_str}")

                self.test_results["taxonomy_system"] = {
                    "status": "PASS",
                    "node_count": len(taxonomy_tree),
                    "sample_nodes": taxonomy_tree[:3] if len(taxonomy_tree) > 0 else []
                }
            else:
                print("   ‚ö†Ô∏è No taxonomy nodes found - using fallback")
                self.test_results["taxonomy_system"] = {
                    "status": "PARTIAL",
                    "node_count": 0,
                    "using_fallback": True
                }

            return True

        except Exception as e:
            self.test_results["taxonomy_system"] = {
                "status": "FAIL",
                "error": str(e)
            }
            print(f"   ‚ùå Taxonomy system test failed: {e}")
            return False

    async def test_embedding_system(self) -> bool:
        """ÏûÑÎ≤†Îî© ÏãúÏä§ÌÖú ÌÖåÏä§Ìä∏"""
        print("\nüßÆ Testing Embedding System...")

        try:
            from apps.api.database import EmbeddingService, db_manager
            from sqlalchemy import text

            # ÏûÑÎ≤†Îî© ÏÉùÏÑ± ÌÖåÏä§Ìä∏
            test_text = "This is a test text for embedding generation."
            print(f"   Generating embedding for: '{test_text}'")

            start_time = time.time()
            embedding = await EmbeddingService.generate_embedding(test_text)
            embedding_time = (time.time() - start_time) * 1000

            if embedding:
                print(f"   ‚úÖ Embedding generated: {len(embedding)} dimensions")
                print(f"   ‚è±Ô∏è Time: {embedding_time:.2f}ms")
                print(f"   üìä Sample values: {embedding[:5]}...")

                # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïùò ÏûÑÎ≤†Îî© ÌòÑÌô© ÌôïÏù∏
                async with db_manager.async_session() as session:
                    query = text("""
                        SELECT
                            COUNT(*) as total_docs,
                            COUNT(embedding) as docs_with_embeddings
                        FROM documents
                    """)
                    result = await session.execute(query)
                    stats = result.fetchone()

                    total_docs = stats[0]
                    docs_with_embeddings = stats[1]
                    coverage = (docs_with_embeddings / max(1, total_docs)) * 100

                    print(f"   üìä Database embeddings: {docs_with_embeddings}/{total_docs} ({coverage:.1f}%)")

                self.test_results["embedding_system"] = {
                    "status": "PASS",
                    "embedding_dimensions": len(embedding),
                    "generation_time_ms": embedding_time,
                    "database_coverage_percent": coverage,
                    "docs_with_embeddings": docs_with_embeddings
                }
            else:
                print("   ‚ö†Ô∏è Embedding generation returned empty result")
                self.test_results["embedding_system"] = {
                    "status": "PARTIAL",
                    "error": "Empty embedding result"
                }

            return True

        except Exception as e:
            self.test_results["embedding_system"] = {
                "status": "FAIL",
                "error": str(e)
            }
            print(f"   ‚ùå Embedding system test failed: {e}")
            return False

    async def run_all_tests(self) -> Dict[str, Any]:
        """Î™®Îì† ÌÖåÏä§Ìä∏ Ïã§Ìñâ"""
        print("üß™ DT-RAG Production System Testing")
        print("=" * 60)

        # ÌÖåÏä§Ìä∏ Ïã§Ìñâ
        tests = [
            ("Database Connection", self.test_database_connection),
            ("Document Operations", self.test_document_operations),
            ("Search Functionality", self.test_search_functionality),
            ("Classification System", self.test_classification_system),
            ("Taxonomy System", self.test_taxonomy_system),
            ("Embedding System", self.test_embedding_system),
        ]

        passed = 0
        total = len(tests)

        for test_name, test_func in tests:
            try:
                result = await test_func()
                if result:
                    passed += 1
            except Exception as e:
                print(f"   ‚ùå {test_name} failed with exception: {e}")
                self.test_results[test_name.lower().replace(" ", "_")] = {
                    "status": "FAIL",
                    "error": f"Exception: {str(e)}"
                }

        # ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ
        total_time = time.time() - self.start_time

        print("\n" + "=" * 60)
        print("üìä TEST SUMMARY")
        print("=" * 60)
        print(f"‚úÖ Passed: {passed}/{total} tests")
        print(f"‚ùå Failed: {total - passed}/{total} tests")
        print(f"‚è±Ô∏è Total time: {total_time:.2f} seconds")

        # ÏÉÅÏÑ∏ Í≤∞Í≥º
        print("\nüìã Detailed Results:")
        for test_name, result in self.test_results.items():
            status_emoji = {"PASS": "‚úÖ", "PARTIAL": "‚ö†Ô∏è", "FAIL": "‚ùå"}
            emoji = status_emoji.get(result["status"], "‚ùì")
            print(f"   {emoji} {test_name.replace('_', ' ').title()}: {result['status']}")

            if "error" in result:
                print(f"      Error: {result['error']}")

        # ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌèâÍ∞Ä
        if passed == total:
            overall_status = "üéâ PRODUCTION READY"
            print(f"\n{overall_status}")
            print("‚úÖ All systems operational")
            print("‚úÖ PostgreSQL + pgvector working")
            print("‚úÖ Hybrid search functional")
            print("‚úÖ ML classification active")
            print("‚úÖ Ready for production deployment")
        elif passed >= total * 0.8:
            overall_status = "‚ö†Ô∏è MOSTLY FUNCTIONAL"
            print(f"\n{overall_status}")
            print("‚úÖ Core systems operational")
            print("‚ö†Ô∏è Some features may be limited")
            print("üí° Check failed tests and resolve issues")
        else:
            overall_status = "‚ùå NEEDS ATTENTION"
            print(f"\n{overall_status}")
            print("‚ùå Critical systems not working")
            print("üîß Database or core functionality issues")
            print("üö® Not ready for production")

        return {
            "overall_status": overall_status,
            "tests_passed": passed,
            "tests_total": total,
            "test_results": self.test_results,
            "total_time_seconds": total_time
        }

async def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    tester = ProductionSystemTester()
    results = await tester.run_all_tests()

    # Í≤∞Í≥ºÎ•º JSON ÌååÏùºÎ°ú Ï†ÄÏû•
    import json
    timestamp = int(time.time())
    results_file = f"test_results_{timestamp}.json"

    try:
        with open(results_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False, default=str)
        print(f"\nüíæ Results saved to: {results_file}")
    except Exception as e:
        print(f"‚ö†Ô∏è Could not save results file: {e}")

    # Ï¢ÖÎ£å ÏΩîÎìú Í≤∞Ï†ï
    success_rate = results["tests_passed"] / results["tests_total"]
    return success_rate >= 0.8  # 80% Ïù¥ÏÉÅ ÌÜµÍ≥ºÌïòÎ©¥ ÏÑ±Í≥µ

if __name__ == "__main__":
    success = asyncio.run(main())
    sys.exit(0 if success else 1)